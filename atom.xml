<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CepheusSun</title>
  <subtitle>Code for a better world.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.CepheusSun.com/"/>
  <updated>2018-01-12T06:29:42.401Z</updated>
  <id>http://www.CepheusSun.com/</id>
  
  <author>
    <name>CepheusSun</name>
    <email>cd_sunyang@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>译 Swift 中的类型擦除</title>
    <link href="http://www.CepheusSun.com/Swift%20%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4.html"/>
    <id>http://www.CepheusSun.com/Swift 中的类型擦除.html</id>
    <published>2018-01-12T06:20:45.000Z</published>
    <updated>2018-01-12T06:29:42.401Z</updated>
    
    <content type="html"><![CDATA[<p>你可能听过这个术语 :<strong>类型擦除</strong>。甚至你也用过标准库中的类型擦除(<code>AnySequence</code>)。但是具体什么是类型擦除, 我们怎么才能实现类型擦除呢？这篇文章就是介绍这件事情的。</p>
<p>在日常的开发中, 总有想要把某个类或者是某些实现细节对其他模块隐藏起来, 不然总会感觉这些类在项目里到处都是。或者想要实现两个不同类之间的互相转换。类型擦除就是一个移除某个类的类型标准， 将其变得更加通用的过程。</p>
<p>到这里很自然的就会想到协议或者是提取抽象的父类来做这件事情。<strong>协议</strong>或者<strong>父类</strong> 就可以看作是一种实现类型擦除的方式。举个例子:</p>
<p><strong>NSString</strong> 在标准库中我们是没办法得到 <code>NSString</code> 的实例的，我们得到的所有的 <code>NSString</code> 对象其实都是标准库中 <code>NSString</code> 的私有子类。这些私有类型对外界可以说是完全隐藏起来了的, 同时可以是用 <code>NSString</code> 的 API 来使用这些实例。所有的子类我们在使用的时候都不需要知道他们具体是什么, 也就不需要考虑他们具体的类型信息了。</p>
<p>在处理 Swift 中的泛型和有关联类型的协议的时候, 就需要一些更高级的东西了。Swift 不允许把协议当作类来使用。如果你想要写一个<strong>接受一个 Int 类型的序列的方法</strong>。这么写是不对的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(seq: Sequence&lt;Int&gt;)</span></span> &#123;...&#125;</div><div class="line"></div><div class="line"><span class="comment">// Compile error： Cannot specialize non-generic type 'Sequence'</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>这种情况下, 我们应该考虑使用的是泛型:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;S: Sequence&gt;<span class="params">(seq: S)</span></span> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Int</span> &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>这样写就可以了。<strong>但是</strong>, 还是有一些情况是比较麻烦的比如说: <strong>我们无法使用这样的代码来表达返回值类型或者是属性</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span>&lt;S: Sequence&gt;<span class="params">()</span></span> -&gt; <span class="type">S</span> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Int</span> &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>这么写并不会是我们想要的那种结果。在这行代码中，我们想要的是返回一个满足条件的类的实例，但是这行代码会允许调用者去选择他想要的具体的类型, 然后 <code>g</code> 这个方法去提供合适的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Fork</span> </span>&#123;</div><div class="line">    associatedtype <span class="type">E</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">()</span></span> -&gt; <span class="type">E</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span>: <span class="title">Fork</span> </span>&#123;</div><div class="line">    <span class="keyword">typealias</span> <span class="type">E</span> = <span class="type">String</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"🐶"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span>: <span class="title">Fork</span> </span>&#123;</div><div class="line">    <span class="keyword">typealias</span> <span class="type">E</span> = <span class="type">Int</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span>&lt;S: Fork&gt;<span class="params">()</span></span> -&gt; <span class="type">S</span> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">E</span> == <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Dog</span>() <span class="keyword">as</span>! <span class="type">S</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在这里可以看出来。g 这个函数具体返回什么东西是在调用的时候决定的。就是说要想正确的使用 g 这个函数必须使用  `let dog: Dog = g()`  这样的代码</span></div><div class="line"><span class="keyword">let</span> dog: <span class="type">Dog</span> = g()</div><div class="line">dog.call()</div><div class="line"></div><div class="line"><span class="comment">// error</span></div><div class="line"><span class="keyword">let</span> dog = g()</div><div class="line"><span class="keyword">let</span> cat: <span class="type">Cat</span> = g()</div></pre></td></tr></table></figure>
<p>Swift 提供了 AnySequence 这个类来解决这个问题。AnySequence 包装了任意的 Sequence 并把他的类型信息给隐藏起来了。然后通过 AnySequence 来代替这个。有了 AnySequence 我们可以这样来写上面的 <code>f</code> 和 <code>g</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(seq: AnySequence&lt;Int&gt;)</span></span> &#123; ... &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> -&gt; <span class="type">AnySequence</span>&lt;<span class="type">Int</span>&gt; &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>这么一来， 泛型没有了， 而且所有具体的类型信息都被隐藏起来了。使用 AnySequence 增加了一点点的复杂性和运行成本，但是代码却更干净了。</p>
<p>Swift 标准库中有很多这样的类型, 比如 <code>AnyCollection</code>, <code>AnyHashable</code>, <code>AnyIndex</code> 等。 在代码中你可以自己定义一些泛型或者协议,  或者直接使用这些特性来简化代码。</p>
<h2 id="基于类的擦除"><a href="#基于类的擦除" class="headerlink" title="基于类的擦除"></a>基于类的擦除</h2><p><strong>我们需要在不公开类型信息的情况下从多个类型中包装出来一些公共的功能</strong>。这很自然就能想到抽象父类。事实上我们确实可以通过<strong>抽象父类</strong>来实现<strong>类型擦除</strong>。父类暴露 API 出来，子类根据具体的类型信息来做具体的实现。我们来看看怎么自己实现一个类似 AnySequence 的东西。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MAnySequence</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Sequence</span> </span>&#123;</div></pre></td></tr></table></figure>
<p>这个类需要实现 <code>iterator</code> 类型作为 <code>makeIterator</code> 的返回类型。我们必须要做两次类型擦除来隐藏底层的序列类型以及迭代器的类型。这种内在的迭代器类型遵守了 <code>IteratorProtocol</code> 协议并且在 <code>next()</code> 方法中使用 <code>fatalError</code> 来抛出异常。Swift 本身是不支持抽象类的， 所以这就足够了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</div><div class="line">        <span class="built_in">fatalError</span>(<span class="string">"Must override next()"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ManySequence</code> 对 <code>makeIterator</code> 方法的实现也差不多， 使用 <code>fatalError</code> 来抛出异常。 这个错误用来提示子类来实现这个功能:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span> &#123;</div><div class="line">    <span class="built_in">fatalError</span>(<span class="string">"Must override makeIterator()"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是<strong>基于类的类型擦除</strong>需要的公共 API。私有的实现需要去子类化这个类。这公共类被元素的类型参数化, 但是私有的实现却在这个类型当中:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MAnySequenceImpl</span>&lt;<span class="title">Seq</span>: <span class="title">Sequence</span>&gt;: <span class="title">MAnySequence</span>&lt;<span class="title">Seq</span>.<span class="title">Element</span>&gt; </span>&#123;</div></pre></td></tr></table></figure>
<p>这个类需要内部的子类来实现上面提到的两个方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorImpl</span>: <span class="title">Iterator</span> </span>&#123;</div></pre></td></tr></table></figure>
<p>这一步包装了这个序列的迭代器的类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorImpl</span>: <span class="title">Iterator</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> wrapped: <span class="type">Seq</span>.<span class="type">Iterator</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> wrapped: <span class="type">Seq</span>.<span class="type">Iterator</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.wrapped = wrapped</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步实现了 <code>next</code> 方法。 实际上是调用它包装的序列的迭代器的 <code>next</code> 方法.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</div><div class="line">    <span class="keyword">return</span> wrapped.next()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相似的， <code>MAnySequenceImpl</code> 是 sequence 的包装。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seq: <span class="type">Seq</span></div><div class="line"></div><div class="line"><span class="keyword">init</span>(<span class="number">_</span> seq: <span class="type">Seq</span>) &#123;</div><div class="line">    <span class="keyword">self</span>.seq = seq</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步实现了 <code>makeIterator</code> 方法。从包装的序列中去获取迭代去对象, 然后把这个迭代器对象包装给 <code>IteratorImpl</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">IteratorImpl</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">IteratorImpl</span>(seq.makeIterator())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还需要一点: 使用 <code>MAnySequence</code> 来初始化一个 <code>MAnySequenceImpl</code>，但是返回值还是标记成 <code>MAnySequence</code> 类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MAnySequence</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">make</span>&lt;Seq: Sequence&gt;<span class="params">(<span class="number">_</span> seq: Seq)</span></span> -&gt; <span class="type">MAnySequence</span>&lt;<span class="type">Element</span>&gt; <span class="keyword">where</span> <span class="type">Seq</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">MAnySequenceImpl</span>&lt;<span class="type">Seq</span>&gt;(seq)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来用一下这个 <code>MAnySequence</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInts</span><span class="params">(<span class="number">_</span> seq: MAnySequence&lt;Int&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> elt <span class="keyword">in</span> seq &#123;</div><div class="line">        <span class="built_in">print</span>(elt)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">printInts(<span class="type">MAnySequence</span>.make(array))</div><div class="line">printInts(<span class="type">MAnySequence</span>.make(array[<span class="number">1</span> ..&lt; <span class="number">4</span>]))</div></pre></td></tr></table></figure>
<h2 id="基于函数的擦除"><a href="#基于函数的擦除" class="headerlink" title="基于函数的擦除"></a>基于函数的擦除</h2><p><strong>我们希望公开多个类型的功能而不公开这些类型。</strong>很自然的方法是储存那些签名只涉及到我们想要公开的类型的函数。函数的主体可以在底层信息已知的上下文中创建。</p>
<p>我们来看看 MAnySequence 要怎么来实现呢？更上面的内容差不多。只是这次因为我们不需要继承而且他只是一个容器，所以我们用 Struct 来实现。</p>
<p>还是声明一个 Struct</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAnySequence</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Sequence</span> </span>&#123;</div></pre></td></tr></table></figure>
<p>跟上面一样, 实现 Sequence 协议需要有一个迭代器(Iterator)来作为返回值。这个东西也是一个 <code>struct</code> 它有一个储存属性, 这个储存属性是一个不接受参数， 返回一个<code>Element?</code>  的函数。 他是 <code>IteratorProtocol</code> 这个协议要求的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Iterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> _next: () -&gt; <span class="type">Element</span>?</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</div><div class="line">        <span class="keyword">return</span> _next()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MAnySequence</code> 跟这个也相似。他包含了一个返回 <code>Iterator</code>  的函数的储存属性。 Sequence 通过调用这个函数来实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _makeIterator: () -&gt; <span class="type">Iterator</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span> &#123;</div><div class="line">    <span class="keyword">return</span> _makeIterator()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MAnySequence</code>  的 <code>init</code> 方法是最重要的地方。他接受任意的 <code>Sequence</code> 作为参数(<code>Sequence&lt;Int&gt;</code>、<code>Sequence&lt;String&gt;</code>):</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>&lt;<span class="type">Seq</span>: <span class="type">Sequence</span>&gt;(<span class="number">_</span> seq: <span class="type">Seq</span>) <span class="keyword">where</span> <span class="type">Seq</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</div></pre></td></tr></table></figure>
<p>然后需要把这个 Sequence 需要的功能包装在这个函数中:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_makeIterator = &#123;</div></pre></td></tr></table></figure>
<p>再然后我们需要在这里做一个迭代器 <code>Sequence</code> 正好有这个东西：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iterator = seq.makeIterator()</div></pre></td></tr></table></figure>
<p>最后我们把这个迭代器包装给 <code>MAnySequence</code>。 他的 <code>_next</code> 函数就能调用到 <code>iterator</code> 的 <code>next</code> 函数了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">            <span class="keyword">return</span> <span class="type">Iterator</span>(_next: &#123; iterator.next() &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面看这个 MAnySequence 是怎么用的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInts</span><span class="params">(<span class="number">_</span> seq: MAnySequence&lt;Int&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> elt <span class="keyword">in</span> seq &#123;</div><div class="line">        <span class="built_in">print</span>(elt)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">printInts(<span class="type">MAnySequence</span>(array))</div><div class="line">printInts(<span class="type">MAnySequence</span>(array[<span class="number">1</span> ..&lt; <span class="number">4</span>]))</div></pre></td></tr></table></figure>
<p>搞定！</p>
<p>这种基于函数的擦除方法在处理需要把一小部分功能作为更大类型的一部分来包装的时候非常有效, 这样做就不需要有单独的类来擦除其他类的类型信息。</p>
<p>比如说，我们需要写一些能在特定几个集合类型上面使用的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericDataSource</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">let</span> <span class="built_in">count</span>: () -&gt; <span class="type">Int</span></div><div class="line">    </div><div class="line">    <span class="keyword">let</span> getElement: (<span class="type">Int</span>) -&gt; <span class="type">Element</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>&lt;<span class="type">C</span>: <span class="type">Collection</span>&gt;(<span class="number">_</span> <span class="built_in">c</span>: <span class="type">C</span>) <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Element</span> == <span class="type">Element</span>, <span class="type">C</span>.<span class="type">Index</span> == <span class="type">Int</span> &#123;</div><div class="line">        <span class="built_in">count</span> = &#123; <span class="type">Int</span>(<span class="built_in">c</span>.<span class="built_in">count</span>) &#125;</div><div class="line">        getElement = &#123; <span class="built_in">c</span>[$<span class="number">0</span> - <span class="built_in">c</span>.startIndex]&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样， <code>GenericDataSource</code> 中的其他代码就能够直接使用 <code>count()</code>、 <code>getElement()</code> 两个方法来操作传入的collection 了。并且这个集合类型不会污染 <code>GenericDataSource</code> 的泛型参数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>类型擦除是个非常有用的技术。他被用来阻止泛型对代码的侵入,  也能够让接口更加的简单。通过将底层的类型信息包装起来, 将 API 和具体的功能分开。使用静态的公有类型或者将 API 包装进函数都能够做到类型擦除。基于函数做类型擦除对那种只需要几个功能的简单情况尤其有用。</p>
<p>Swift 标准库提供了一些可以直接使用的类型擦除。<code>AnySequence</code> 是 <code>Sequence</code> 的包装,  从名字可以看出来, 他允许你在不知道具体类型的情况下迭代遍历某个序列。<code>AnyIterator</code> 是他的好朋友, 它提供了一个类型已经被擦除掉的迭代器。<code>AnyHashable</code> 包装了类型擦除掉了的 <code>Hashable</code> 类型。Swift 中还有一些基于集合类型的协议。在文档中搜索 “Any” 就可以看到。标准库中的 <code>Codable</code> 也有用到了类型擦除： <code>KeyedEncodingContainer</code> 和 <code>KeyedDecodingContainer</code> 都是对应协议类型擦除的包装。他们用来在不知道具体类型信息的情况下实现 encode 还有 decode。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>前几天看到 MikeAsh 最新的 <em>Friday Q&amp;A</em> <a href="https://www.mikeash.com/pyblog/friday-qa-2017-12-08-type-erasure-in-swift.html">Type Erasure in Swift</a>。想趁着最近没什么事情翻译一下的。结果最近一直沉迷吃鸡， 没有时间去做这件事情。所以…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你可能听过这个术语 :&lt;strong&gt;类型擦除&lt;/strong&gt;。甚至你也用过标准库中的类型擦除(&lt;code&gt;AnySequence&lt;/code&gt;)。但是具体什么是类型擦除, 我们怎么才能实现类型擦除呢？这篇文章就是介绍这件事情的。&lt;/p&gt;
&lt;p&gt;在日常的开发中, 总有想要把某个类或者是某些实现细节对其他模块隐藏起来, 不然总会感觉这些类在项目里到处都是。或者想要实现两个不同类之间的互相转换。类型擦除就是一个移除某个类的类型标准， 将其变得更加通用的过程。&lt;/p&gt;
&lt;p&gt;到这里很自然的就会想到协议或者是提取抽象的父类来做这件事情。&lt;strong&gt;协议&lt;/strong&gt;或者&lt;strong&gt;父类&lt;/strong&gt; 就可以看作是一种实现类型擦除的方式。举个例子:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NSString&lt;/strong&gt; 在标准库中我们是没办法得到 &lt;code&gt;NSString&lt;/code&gt; 的实例的，我们得到的所有的 &lt;code&gt;NSString&lt;/code&gt; 对象其实都是标准库中 &lt;code&gt;NSString&lt;/code&gt; 的私有子类。这些私有类型对外界可以说是完全隐藏起来了的, 同时可以是用 &lt;code&gt;NSString&lt;/code&gt; 的 API 来使用这些实例。所有的子类我们在使用的时候都不需要知道他们具体是什么, 也就不需要考虑他们具体的类型信息了。&lt;/p&gt;
&lt;p&gt;在处理 Swift 中的泛型和有关联类型的协议的时候, 就需要一些更高级的东西了。Swift 不允许把协议当作类来使用。如果你想要写一个&lt;strong&gt;接受一个 Int 类型的序列的方法&lt;/strong&gt;。这么写是不对的:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(seq: Sequence&amp;lt;Int&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;...&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Compile error： Cannot specialize non-generic type &#39;Sequence&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
      <category term="翻译" scheme="http://www.CepheusSun.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>新手应该怎么写 Swift</title>
    <link href="http://www.CepheusSun.com/%E6%96%B0%E6%89%8B%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%20Swift.html"/>
    <id>http://www.CepheusSun.com/新手应该怎么写 Swift.html</id>
    <published>2017-12-19T16:00:00.000Z</published>
    <updated>2017-12-20T06:49:58.776Z</updated>
    
    <content type="html"><![CDATA[<p>已经有好几个人跟我抱怨过为什么 swift 里面有那么多问号(<code>?</code>)还有叹号(<code>!</code>)了。恰恰哈, 在刚刚开始写 swift 的时候, 我也面临着这种问题。</p>
<p>昨天一个朋友发了我一行代码, 让我看看应该怎么写:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> pageiid = (<span class="keyword">self</span>.pageid?.intValue)! + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这段代码看起来很操蛋, 但是糟心的是, 在刚刚写 swift 的时候， 我写过更恶心的代码。</p>
<p>既然大家在刚刚开始写 swift 的时候都遇到了这个问题。今天就来看看, 这样的代码应该怎样写才能让我们更爽。</p>
<a id="more"></a>
<p>我们都知道, 有问号(<code>?</code>)和叹号(<code>!</code>)的原因是什么？—<strong>Optional</strong></p>
<p>相信准备要试试 swift 的人，或多或少都看到过, 或者听说过这是 swift 相较于 oc 很大的区别。在我看来，除了语法上的变化以外， swift 和 oc 最大的区别就在 于<code>optional</code> 了。为了照顾到实在是太新的新手(毕竟我自己也是新手)。还是简单的讲讲这个东西吧！</p>
<h2 id="什么是-Optional"><a href="#什么是-Optional" class="headerlink" title="什么是 Optional"></a>什么是 Optional</h2><p>这一点就没什么可说的，在 swift 中 Optional 实际上是一个枚举。如果要自己实现一个类似的东西的话,  核心的代码应该是这样的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这段代码不重要</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SYOptional</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">case</span> <span class="keyword">none</span></div><div class="line">    <span class="keyword">case</span> some(<span class="type">Wrapped</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码只是要告诉你, 这个枚举只有两个 case,  一个是 <code>.none</code> 代表这个 optional 是没有值的, 也就是说他是 nil。另外一个值 <code>.some</code> 代表这个 optional 是有值的。</p>
<p>苹果为什么要引入 optional 这个概念, 在这个地方就不打算赘述了。看下面一段话: </p>
<blockquote>
<p>“Optional 可以说是 Swift 的一大特色，它完全解决了 “有” 和 “无” 这两个困扰了 Objective-C 许久的哲学概念，也使得代码安全性得到了很大的增加。”</p>
<p>摘录来自: 王巍 (onevcat). “Swifter - Swift 必备 Tips (第四版)”。 iBooks. </p>
</blockquote>
<p>个人认为 optional 确实是 swift 中非常好的新特性了。</p>
<p>接下来, 我们看看 Optional 的那几个操作符号: <code>??</code>/ <code>!</code>/<code>?</code></p>
<p>这些无非就是一些 swift 中的语法糖而已。具体什么意思，我们来往下看。</p>
<h3 id="？"><a href="#？" class="headerlink" title="？"></a>？</h3><p><em>在声明一个变量或者属性的时候:</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>?</div></pre></td></tr></table></figure>
<p>最后的<code>?</code>表示这个 <code>optionalString</code> 是一个可选类型(optional)。这里的 <code>String？</code> 就是 <code>Optional&lt;String&gt;</code> 的意思。</p>
<p><em>在使用变量的时候:</em></p>
<p>如果这样写编译器是会报错的, </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">optionalString.lowercased()</div></pre></td></tr></table></figure>
<p>这时候编译器会提示你在 <code>optionalString</code> 后面添加一个<code>?</code></p>
<p>这个问号就是告诉编译器这个 <code>optionalString</code> 是一个可选类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>!</div><div class="line">    <span class="keyword">var</span> son: <span class="type">Son</span>!</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p: <span class="type">Person</span>?</div><div class="line"></div><div class="line"><span class="built_in">print</span>(p?.son.name)</div><div class="line"><span class="comment">// Playground: nil</span></div></pre></td></tr></table></figure>
<p>这段代码表示，如果在一行代码里的某个地方出现 nil 着, 这行代码也将会返回 nil。(这一点有点类似 oc 中给 nil 发送消息)。这样写有一个好处，就是在维护代码的时候, 看到 ？就知道这个东西是可选类型了。也就是<strong>告诉我们在程序运行期间这个东西是可能为空的。</strong></p>
<h3 id="！"><a href="#！" class="headerlink" title="！"></a>！</h3><p>接下来就是 <code>!</code>  了。这个东西跟<code>?</code> 一样。</p>
<p><em>在声明一个变量或者属性的时候:</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> something: <span class="type">String</span>!</div></pre></td></tr></table></figure>
<p>这个用法有一个专门的叫法：<strong>隐式解包可选类型</strong>。 这是一个特殊的可选类型，在对他的成员或者是方法进行访问的时候，编译器会自动的帮我们自动解包。也就说说编译器会自动帮我们加上<code>!</code> 这个符号。换成我们自己的话可以这样理解:</p>
<p><strong>在声明一个变量或者属性的时候，如果我们明确的知道在程序运行过程中访问到这个变量或者属性的时候，他的值一定不为空。那么就可以使用隐式解包可选类型。</strong>如果要举例的话: 我想我会举 XIB 的例子。从 SB 或者 XIB 中拖出来的控件, 都是这样子声明的。</p>
<p><em>在访问变量或者属性的时候:</em></p>
<p>对于一个可选类型来说， 有些时候编译器会提醒我们在这个对象后面添加<code>!</code> 就像最开始我朋友发给我的代码一样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> pageiid = (<span class="keyword">self</span>.pageid?.intValue)! + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>如果一个方法需要传入的是一个不可选类型作为参数。这时候如果强制传入一个可选类型的话。编译器就会报错，并且提醒我们在这个可选类型变量后面添加一个<code>!</code> 。 这个做法就是<strong>强制解包</strong>。 相当于是直接访问这个可选类型的 <code>.some</code> 。 </p>
<h3 id=""><a href="#" class="headerlink" title="??"></a>??</h3><p>这个只需要花一句话就能够讲清楚了，这是给这个 optional 默认值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>?</div><div class="line"><span class="keyword">var</span> defaultValue = optionalString ?? <span class="string">"defaultValue"</span></div></pre></td></tr></table></figure>
<p>如果 <code>optionalString</code> 有值的话  <code>defaultValue</code> 就是  <code>optionalString</code> 的值。反之就是 <code>&quot;defaultValue&quot;</code>。</p>
<h2 id="怎么写好-Optional"><a href="#怎么写好-Optional" class="headerlink" title="怎么写好 Optional"></a>怎么写好 Optional</h2><p>大概讲完了一些基本的概念。下面就来说说如何避免在代码中出现各种 <code>?</code> \ <code>!</code> 的情况。其实对新手来说。几乎都是因为编译器提示，然后自动加上去的各种 <code>?</code> 和 <code>!</code> 。 不得不说，这样的代码是非常丑陋的。要解决这个问题, 知道 optional 的原理当然是最重要的。</p>
<h3 id="避免使用-Optional"><a href="#避免使用-Optional" class="headerlink" title="避免使用 Optional"></a>避免使用 Optional</h3><p>写了一段时间之后，我发现很多时候 optional 的使用都是没有什么意义的。就像我朋友给我的例子一样。我们可以通过设置初始值的方法来避免使用 optional</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pageid: <span class="type">Int</span> = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>通过这种方法就能够避免使用到 optional， 也就不会有下面的事情了。当然还可以使用懒加载:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> tableView = <span class="type">UITableView</span>()</div></pre></td></tr></table></figure>
<p>保证在第一次使用这个属性的时候这个属性是肯定被初始化出来了的。</p>
<p>当然还可以通过使用隐式解包可选类型去避免之后的代码中出现 <code>?</code> \ <code>!</code></p>
<p>但是这个其实是不被鼓励的。</p>
<blockquote>
<p>默认不要隐式解包可选类型。 在大多数场景中你都可能会忘掉这件事情。但是在一些特殊情况下应该这样做来减少编译器的压力。而且我们也需要去理解这件事情背后的逻辑。</p>
</blockquote>
<h3 id="如何访问-Optional"><a href="#如何访问-Optional" class="headerlink" title="如何访问 Optional"></a>如何访问 Optional</h3><p>既然设计出来的 Optional 肯定在编码的过程中不可避免的要使用到它。那么在使用 Optional 的时候怎么去避免出现像最开始的那种情况呢？</p>
<p>还是来看这行代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> pageiid = (<span class="keyword">self</span>.pageid?.intValue)! + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>在这里如果 <code>pageid</code> 为空的话， 强制解包是肯定会崩溃的。这种情况应该怎么写呢？除了最开始说的声明的时候设置初始值，还有就是给默认值。另外还有 Optional Map 这种方法来访问 Optioal：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> optionalVal = <span class="keyword">optional</span> &#123;</div><div class="line"> <span class="comment">// do someThing</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">optional</span>.<span class="built_in">map</span>&#123; <span class="comment">// do someThing &#125;</span></div></pre></td></tr></table></figure>
<p>另外还有一些我在网上搜集的 snippet 也能够很舒服的解决一些问题:给 Optional 加一个 extension:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>添加一些方法:基本上都来自 <a href="https://github.com/JohnSundell/SwiftTips">GitHub</a> 这个库</p>
<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p>可以强制要求某个 Optional 在当前行不为空，为空的话会跑出异常。这个相当于是优化了强制解包的异常信息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/// 强制要求这个 optional 不为空</span></div><div class="line">   <span class="comment">///</span></div><div class="line">   <span class="comment">/// 这个方法返回 optional 的值，或者在optional 为空的时候触发 error</span></div><div class="line">   <span class="comment">///</span></div><div class="line">   <span class="comment">///</span></div><div class="line">   <span class="comment">/// - Parameters:</span></div><div class="line">   <span class="comment">///   - hint: 为空抛出的错误信息</span></div><div class="line">   <span class="comment">///</span></div><div class="line">   <span class="comment">/// - Returns: optional 的值.    </span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">require</span><span class="params">(hint hintExpression: @autoclosure<span class="params">()</span></span></span> -&gt; <span class="type">String</span>? = <span class="literal">nil</span>,</div><div class="line">                file: <span class="type">StaticString</span> = #file,</div><div class="line">                line: <span class="type">UInt</span> = #line) -&gt; <span class="type">Wrapped</span> &#123;</div><div class="line">       <span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">var</span> message = <span class="string">"required value was nil <span class="subst">\(file)</span>, at line <span class="subst">\(line)</span>"</span></div><div class="line">           <span class="keyword">if</span> <span class="keyword">let</span> hint = hintExpression() &#123;</div><div class="line">               message.append(<span class="string">". Debugging hit: <span class="subst">\(hint)</span>"</span>)</div><div class="line">           &#125;</div><div class="line">           #<span class="keyword">if</span> !os(<span class="type">Linux</span>)</div><div class="line">           <span class="keyword">let</span> exception = <span class="type">NSException</span>(name: .invalidArgumentException,</div><div class="line">                                       reason: message,</div><div class="line">                                       userInfo: <span class="literal">nil</span>)</div><div class="line">           exception.raise()</div><div class="line">           #endif</div><div class="line">           </div><div class="line">           <span class="built_in">preconditionFailure</span>(message)</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> unwrapped</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="or"><a href="#or" class="headerlink" title="or"></a>or</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 用来代替 ?? 操作符, 这样写可读性高些</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// - Sample:</span></div><div class="line"><span class="comment">//  var a: String? = nil</span></div><div class="line"><span class="comment">//  let res = a.or("b")</span></div><div class="line"><span class="function"><span class="keyword">func</span> `<span class="title">or</span>`<span class="params">(value: Wrapped?)</span></span> -&gt; <span class="type">Optional</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span> ?? value</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="hasSome"><a href="#hasSome" class="headerlink" title="hasSome"></a>hasSome</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 用来判断这个 Optional 是不是为空了。</span></div><div class="line"><span class="keyword">var</span> hasSome: <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>: <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    <span class="keyword">case</span> .some: <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ifSome-ifNone"><a href="#ifSome-ifNone" class="headerlink" title="ifSome   ifNone"></a>ifSome   ifNone</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// 如果 optional 不为空的话，执行闭包， 并返回这个 Optional</span></div><div class="line">@discardableResult</div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">ifSome</span><span class="params">(<span class="number">_</span> handler: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Optional</span> &#123;</div><div class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">       <span class="keyword">case</span> .some(<span class="keyword">let</span> wrapped): handler(wrapped); <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">       <span class="keyword">case</span> .<span class="keyword">none</span>: <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 如果 optional 为空的话，执行闭包， 并返回这个 Optional</span></div><div class="line">   @discardableResult</div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">ifNone</span><span class="params">(<span class="number">_</span> handler: <span class="params">()</span></span></span> -&gt; ()) -&gt; <span class="type">Optional</span> &#123;</div><div class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">       <span class="keyword">case</span> .some: <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">       <span class="keyword">case</span> .<span class="keyword">none</span>: handler(); <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了避免写出满是 <code>?</code> 和 <code>!</code> 的代码, 掌握 Swift 中可选类型的基本知识是很必要的。另外也需要去了解 Swift 中为什么要引入可选类型这个概念。在编写 Swift 代码的时候，需要我们程序员时刻知道程序的逻辑是怎么样的，在设计一个类的时候, 要清楚它的属性在其生命周期中那些是可能为空的。在没有必要的时候，尽量的避免是用  Optional 减少 Optional 的使用，一方面能让你的代码逻辑更可控，一方面也能让你的代码更漂亮。至少不会再被编译器一步一步的搞出那些恶心的东西。<strong>想清楚逻辑, 合理的规避, 加上一些小手段, 让代码更漂亮, 是一件很幸福的事情。</strong> Optional 能够让代码逻辑更明确, 减少很多不必要的crash，如果不当使用, crash 也不会少哦。</p>
<p>最后我一直觉得，掌握了 Optional 是怎么回事， 以及 Optional 怎么用最好， 基本上就算是入门了 Swift 了。</p>
<p>对了朋友的代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pageiid: <span class="type">NSString</span>?   <span class="comment">// 这是属性声明</span></div><div class="line"><span class="keyword">let</span> pageiid = (<span class="keyword">self</span>.pageid?.intValue)! + <span class="number">1</span>  <span class="comment">// 这是某个方法里面的代码</span></div></pre></td></tr></table></figure>
<ul>
<li>为什么要用 NSString?</li>
<li>为什么要 Optional</li>
<li>为什么要强制解包?</li>
</ul>
<p>为什么要 NSString？这个我真不知道， 他只说了接口要一个字符串；为什么要 Optional？这个我也不知道；为什么要强制解包？这我知道，肯定是 Xcode 自动帮他改的啊😂</p>
<p>然后我给他改成了这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pageid: <span class="type">Int</span> = <span class="number">0</span> </div><div class="line"><span class="keyword">self</span>.pageid +=<span class="number">1</span></div><div class="line"><span class="string">"<span class="subst">\(<span class="keyword">self</span>.pageid)</span>"</span></div></pre></td></tr></table></figure>
<p>初始化的时候默认初始值为0，避免 Optional 的使用也避免了后面的强制解包。</p>
<p>使用 Int 代替 NSString。第一是不想用 NSString， 第二是，在业务逻辑中，这个值应该就是 int 类型的</p>
<p>在接口组装参数的地方，将 int 转换成字符串。这个逻辑应该是接口的事情，不应该拿业务层的逻辑去将就它。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经有好几个人跟我抱怨过为什么 swift 里面有那么多问号(&lt;code&gt;?&lt;/code&gt;)还有叹号(&lt;code&gt;!&lt;/code&gt;)了。恰恰哈, 在刚刚开始写 swift 的时候, 我也面临着这种问题。&lt;/p&gt;
&lt;p&gt;昨天一个朋友发了我一行代码, 让我看看应该怎么写:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pageiid = (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.pageid?.intValue)! + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码看起来很操蛋, 但是糟心的是, 在刚刚写 swift 的时候， 我写过更恶心的代码。&lt;/p&gt;
&lt;p&gt;既然大家在刚刚开始写 swift 的时候都遇到了这个问题。今天就来看看, 这样的代码应该怎样写才能让我们更爽。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中 class 怎么支持 Codable</title>
    <link href="http://www.CepheusSun.com/Swift-%E4%B8%AD-class-%E6%80%8E%E4%B9%88%E6%94%AF%E6%8C%81-Codable.html"/>
    <id>http://www.CepheusSun.com/Swift-中-class-怎么支持-Codable.html</id>
    <published>2017-12-15T03:34:57.000Z</published>
    <updated>2017-12-15T03:34:54.014Z</updated>
    
    <content type="html"><![CDATA[<p>之前翻译过 <a href="www.mikeash.com">Mike Ash</a> 的文章 <a href="http://www.jianshu.com/p/febdd25ae525">Swift 4.0: Codable</a>。 之后有读者<a href="http://www.jianshu.com/u/a1045c1ac0ce"><a href="http://www.jianshu.com/u/a1045c1ac0ce">DevHank</a></a> 提了个问题:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1769276-2e0f76a36a18ce9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>迅速的在 Playgrounds 上面下写了一个例子:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Father: Codable &#123;</div><div class="line">    var familyName: String = ""</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Son: Father &#123;</div><div class="line">    var name: String = ""  </div><div class="line">&#125;</div><div class="line"></div><div class="line">let jsonText = """</div><div class="line">&#123;</div><div class="line">    "familyName": "F",</div><div class="line">    "name": "N"</div><div class="line">&#125;</div><div class="line">"""</div><div class="line"></div><div class="line">let data = jsonText.data(using: .utf8)!</div><div class="line">do &#123;</div><div class="line">    let son: Son = try JSONDecoder().decode(Son.self, from: data)</div><div class="line">    print(son.familyName)</div><div class="line">&#125; catch let error &#123;</div><div class="line">    print(error)</div><div class="line">&#125;</div><div class="line">// F</div></pre></td></tr></table></figure>
<p>我以为事情就算结束了。后来实在是有些不妥, 然后在代码中添加</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(son.name)</div></pre></td></tr></table></figure>
<p>发现出了问题。所以尝试让子类遵守 Codable 协议。 两个类的代码改成了这样</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> familyName: <span class="type">String</span> = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>: <span class="title">Father</span>, <span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span>   </div><div class="line">&#125;</div><div class="line"><span class="comment">// N</span></div></pre></td></tr></table></figure>
<p>不难得出结论:<strong>简单的添加 Codable， 在继承中是无效的。在哪个类中遵守的 Codable， 其子类或者父类的成员都会被忽略。</strong></p>
<p>再回到 <a href="http://www.jianshu.com/p/febdd25ae525">Swift 4.0: Codable</a>这篇文章中：有这么一句话</p>
<blockquote>
<p>编译器会自动生成对应的 key 嵌套在 Person 类中。如果我们自己来做这件事情，这个嵌套类型会是这样的。</p>
</blockquote>
<p>也就是说, 相关的 <code>CodingKey</code> 和 <code>encode(to:)</code> 、<code>init(from:)</code>方法都是编译器加上去的。这么看来这个问题就有解决方案了:<strong>自己实现 Codable 以及相关的实现。</strong></p>
<p>这段话我在 <a href="https://developer.apple.com/videos/play/wwdc2017/212/">WWDC</a> (大概第28、9分钟)中，得到了苹果官方的证实。</p>
<p>所以又写了下面的代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> familyName: <span class="type">String</span> = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>: <span class="title">Father</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> name = <span class="string">"name"</span></div><div class="line">        <span class="keyword">case</span> familyName = <span class="string">"familyName"</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果要 JSON -&gt; Son 必须实现这个方法</span></div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">        <span class="keyword">let</span> container = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</div><div class="line">        name = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .name)</div><div class="line">        familyName = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .familyName)</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">// 如果要 Son -&gt; JSON 必须实现这个方法</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</div><div class="line">        <span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</div><div class="line">        <span class="keyword">try</span> container.encode(name, forKey: .name)</div><div class="line">        <span class="keyword">try</span> container.encode(familyName, forKey: .familyName)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//N</span></div><div class="line"><span class="comment">//F</span></div></pre></td></tr></table></figure>
<p>这段代码中, 父类遵守了 Codable 协议, 然后我在子类中自己实现了 CodingKey 相关的代码。最后的结果, 也是可喜的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前翻译过 &lt;a href=&quot;www.mikeash.com&quot;&gt;Mike Ash&lt;/a&gt; 的文章 &lt;a href=&quot;http://www.jianshu.com/p/febdd25ae525&quot;&gt;Swift 4.0: Codable&lt;/a&gt;。 之后有读者&lt;a href=&quot;http://www.jianshu.com/u/a1045c1ac0ce&quot;&gt;&lt;a href=&quot;http://www.jianshu.com/u/a1045c1ac0ce&quot;&gt;DevHank&lt;/a&gt;&lt;/a&gt; 提了个问题:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1769276-2e0f76a36a18ce9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;迅速的在 Playgrounds 上面下写了一个例子:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;class Father: Codable &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    var familyName: String = &quot;&quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;class Son: Father &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    var name: String = &quot;&quot;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;let jsonText = &quot;&quot;&quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &quot;familyName&quot;: &quot;F&quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &quot;name&quot;: &quot;N&quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&quot;&quot;&quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;let data = jsonText.data(using: .utf8)!&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;do &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    let son: Son = try JSONDecoder().decode(Son.self, from: data)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(son.familyName)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; catch let error &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(error)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// F&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我以为事情就算结束了。后来实在是有些不妥, 然后在代码中添加&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(son.name)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;发现出了问题。所以尝试让子类遵守 Codable 协议。 两个类的代码改成了这样&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>ExpressibleByStringLiteral</title>
    <link href="http://www.CepheusSun.com/ExpressibleByStringLiteral.html"/>
    <id>http://www.CepheusSun.com/ExpressibleByStringLiteral.html</id>
    <published>2017-11-26T16:00:00.000Z</published>
    <updated>2017-11-27T08:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>从字面意思上看，<strong>通过字符串字面意思表达</strong>。这是一个协议,  就是说实现这个协议可以通过字面意思实例化这个类。</p>
<p>我们查看 String 这个类, Swift 实际上已经给 String 这个类实现了 <code>ExpressibleByStringLiteral</code> 这个协议。所以可以通过</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> aString = <span class="string">"this is a string"</span></div></pre></td></tr></table></figure>
<p>来初始化一个 String 对象。通过查看<a href="https://developer.apple.com/documentation/swift/expressiblebystringliteral">文档</a>：</p>
<p>这个协议已经被</p>
<ul>
<li>CSLocalizedString</li>
<li>StaticString</li>
<li>NSMutableString</li>
<li>String</li>
<li>NSString</li>
<li>SubString</li>
<li>Selector</li>
</ul>
<p>这几个东西实现了。</p>
<p>这个协议有什么用呢？其实我们可以通过实现这个协议，来帮助我们更简单的初始化一些东西。比如说: URL。</p>
<p>在实际开发中, 每次初始化一个 URL 都需要</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> urls = <span class="type">URL</span>.<span class="keyword">init</span>(string: <span class="string">"https://www.baidu.com"</span>)</div></pre></td></tr></table></figure>
<p>这样来初始化一个 URL 出来， 这个初始化出来的 URL 又是一个 optional 的，在使用的使用还需要给他解包什么的。但是每次都要这样实在是很烦。所以我们可以通过这个协议来简化这个过程。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URL</span>: <span class="title">ExpressibleByStringLiteral</span> </span>&#123;</div><div class="line">    </div><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) &#123;</div><div class="line">	<span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"<span class="subst">\(value)</span>"</span>) <span class="keyword">else</span> &#123;</div><div class="line">		<span class="built_in">preconditionFailure</span>(<span class="string">"This url: <span class="subst">\(value)</span> is not invalid"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">self</span> = url</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>这样就可以通过</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> url: <span class="type">URL</span> = <span class="string">"https://www.baidu.com"</span></div><div class="line"><span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: url)</div><div class="line"><span class="keyword">let</span> task2 = <span class="type">URLSession</span>.shared.dataTask(with: <span class="string">"https://www.baidu.com"</span>)</div></pre></td></tr></table></figure>
<p>这种方式去初始化一个 URL 了，然后当这个 URL 不对的时候就会抛出异常。</p>
<p>当然还有一些其他的类, 也可以通过实现这个协议的方式来做这件事情。比如说:</p>
<p>我们有一个商品类</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> `id`: <span class="type">String</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个结构体我们需要这样实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p = <span class="type">Product</span>(id: <span class="string">"xx"</span>)</div></pre></td></tr></table></figure>
<p>这时候我们再实现这个协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Product</span>: <span class="title">ExpressibleByStringLiteral</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span> = <span class="type">Product</span>(id: value)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> p2: <span class="type">Product</span> = <span class="string">"xx"</span></div></pre></td></tr></table></figure>
<p>当然还可以直接通过一个字符串初始化一个 Controller 这种做法。</p>
<p><strong>当然，本人还是不支持对这种自定义的类做这种事情，确实是一种非常风骚的做法。暂时没有想到十分具体的场景。但是知道这个小技巧还是很不错的。</strong></p>
<p>不过，对<code>URL</code> <code>Date</code> 这类，在开发中经常会以字符串来表示，但是又是字符串东西来说，这样去写还是挺不错的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Date</span>: <span class="title">ExpressibleByStringLiteral</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">let</span> dateformatter = <span class="type">DateFormatter</span>()</div><div class="line">        dateformatter.dateFormat = <span class="string">"YYYY-MM-dd"</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> date = dateformatter.date(from: value) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">preconditionFailure</span>(<span class="string">"This date: <span class="subst">\(value)</span> is not invalid"</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">self</span> = date</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> date: <span class="type">Date</span> = <span class="string">"1990-09-09"</span></div></pre></td></tr></table></figure>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-11-27-070845.png" alt=""></p>
<p>看了一下，还有好几种类似的协议。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从字面意思上看，&lt;strong&gt;通过字符串字面意思表达&lt;/strong&gt;。这是一个协议,  就是说实现这个协议可以通过字面意思实例化这个类。&lt;/p&gt;
&lt;p&gt;我们查看 String 这个类, Swift 实际上已经给 String 这个类实现了 &lt;code&gt;ExpressibleByStringLiteral&lt;/code&gt; 这个协议。所以可以通过&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; aString = &lt;span class=&quot;string&quot;&gt;&quot;this is a string&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;来初始化一个 String 对象。通过查看&lt;a href=&quot;https://developer.apple.com/documentation/swift/expressiblebystringliteral&quot;&gt;文档&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;这个协议已经被&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSLocalizedString&lt;/li&gt;
&lt;li&gt;StaticString&lt;/li&gt;
&lt;li&gt;NSMutableString&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;NSString&lt;/li&gt;
&lt;li&gt;SubString&lt;/li&gt;
&lt;li&gt;Selector&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几个东西实现了。&lt;/p&gt;
&lt;p&gt;这个协议有什么用呢？其实我们可以通过实现这个协议，来帮助我们更简单的初始化一些东西。比如说: URL。&lt;/p&gt;
&lt;p&gt;在实际开发中, 每次初始化一个 URL 都需要&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; urls = &lt;span class=&quot;type&quot;&gt;URL&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;(string: &lt;span class=&quot;string&quot;&gt;&quot;https://www.baidu.com&quot;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样来初始化一个 URL 出来， 这个初始化出来的 URL 又是一个 optional 的，在使用的使用还需要给他解包什么的。但是每次都要这样实在是很烦。所以我们可以通过这个协议来简化这个过程。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;URL&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;ExpressibleByStringLiteral&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;(stringLiteral value: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; url = &lt;span class=&quot;type&quot;&gt;URL&lt;/span&gt;(string: &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(value)&lt;/span&gt;&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;preconditionFailure&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;This url: &lt;span class=&quot;subst&quot;&gt;\(value)&lt;/span&gt; is not invalid&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = url&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>最近很火的 Safe Area 到底是什么</title>
    <link href="http://www.CepheusSun.com/SafeArea.html"/>
    <id>http://www.CepheusSun.com/SafeArea.html</id>
    <published>2017-10-23T16:00:00.000Z</published>
    <updated>2017-10-24T08:38:49.358Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 7 之后苹果给 <em>UIViewController</em> 引入了 <em>topLayoutGuide</em> 和 <em>bottomLayoutGuide</em> 两个属性来描述不希望被透明的状态栏或者导航栏遮挡的最高位置(status bar, navigation bar, toolbar, tab bar 等)。这个属性的值是一个 length 属性( <em>topLayoutGuide.length</em>)。 这个值可能由当前的 ViewController 或者 NavigationController 或者 TabbarController 决定。</p>
<ul>
<li>一个独立的ViewController，不包含于任何其他的ViewController。如果状态栏可见，topLayoutGuide表示状态栏的底部，否则表示这个ViewController的上边缘。</li>
<li>包含于其他ViewController的ViewController不对这个属性起决定作用，而是由容器ViewController决定这个属性的含义：<ul>
<li>如果导航栏（Navigation Bar）可见，topLayoutGuide表示导航栏的底部。</li>
<li>如果状态栏可见，topLayoutGuide表示状态栏的底部。</li>
<li>如果都不可见，表示ViewController的上边缘。<br>这部分还比较好理解，总之是屏幕上方任何遮挡内容的栏的最底部。</li>
</ul>
</li>
</ul>
<p>iOS 11 开始弃用了这两个属性， 并且引入了 Safe Area 这个概念。苹果建议: <strong>不要把 Control 放在 Safe Area 之外的地方</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// These objects may be used as layout items in the NSLayoutConstraint API</span></div><div class="line"><span class="meta">@available</span>(iOS, introduced: <span class="number">7.0</span>, deprecated: <span class="number">11.0</span>)</div><div class="line">open <span class="keyword">var</span> topLayoutGuide: <span class="type">UILayoutSupport</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line"><span class="meta">@available</span>(iOS, introduced: <span class="number">7.0</span>, deprecated: <span class="number">11.0</span>)</div><div class="line">open <span class="keyword">var</span> bottomLayoutGuide: <span class="type">UILayoutSupport</span> &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>今天, 来研究一下 iOS 11 中新引入的这个 API。</p>
<a id="more"></a>
<h3 id="UIView-中的-safe-area"><a href="#UIView-中的-safe-area" class="headerlink" title="UIView 中的 safe area"></a>UIView 中的 safe area</h3><p>iOS 11 中 UIViewController 的 topLayoutGuide 和 bottonLayoutGuide 两个属性被 UIView 中的 safe area 替代了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">open <span class="keyword">var</span> safeAreaInsets: <span class="type">UIEdgeInsets</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">safeAreaInsetsDidChange</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p><strong>safeAreaInsets</strong></p>
<p>这个属性表示相对于屏幕四个边的间距， 而不仅仅是顶部还有底部。这么说好像没有什么感觉, 我们来看一看这个东西分别在 iPhone X 和 iPhone 8 中是什么样的吧！</p>
<p>什么都没有做, 只是新建了一个工程然后在 <code>Main.storyboard</code> 中的 <em>UIViewController</em> 中拖了一个橙色的 View 并且设置约束为:</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-23-035620.jpg" width="300"><br><br></center>

<p>在 <code>ViewController.swift</code> 的 <code>viewDidLoad</code> 中打印</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        <span class="built_in">print</span>(view.safeAreaInsets)</div><div class="line">    &#125;</div><div class="line"><span class="comment">// 无论是iPhone 8 还是 iPhone X 输出结果均为</span></div><div class="line"><span class="comment">// UIEdgeInsets(top: 0.0, left: 0.0, bottom: 0.0, right: 0.0)</span></div></pre></td></tr></table></figure>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-23-035012.jpg" width="500"><br><br></center>

<center>iPhone 8 VS iPhone X Safe Area (竖屏)</center>

<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-23-035302.jpg" width="500"><br><br></center>

<center>iPhone 8 VS iPhone X Safe Area (横屏)</center>

<p>这样对比可以看出, iPhone X 同时具有上下, 还有左右的 Safe Area。</p>
<p><strong>再来看这个例子: </strong> 拖两个自定义的 View, 这个 View 上有一个 显示很多字的Label。然后设置这两个 View 的约束分别是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> view1 = <span class="type">MyView</span>()</div><div class="line"><span class="keyword">let</span> view2 = <span class="type">MyView</span>()</div><div class="line">view.addSubview(view1)</div><div class="line">view.addSubview(view2)</div><div class="line"><span class="keyword">let</span> screenW = <span class="type">UIScreen</span>.main.bounds.size.width</div><div class="line"><span class="keyword">let</span> screenH = <span class="type">UIScreen</span>.main.bounds.size.height</div><div class="line"></div><div class="line">view1.frame = <span class="type">CGRect</span>(</div><div class="line">	x: <span class="number">0</span>,</div><div class="line">	y: <span class="number">0</span>,</div><div class="line">	width:screenW,</div><div class="line">	height: <span class="number">200</span>)</div><div class="line"></div><div class="line">view2.frame = <span class="type">CGRect</span>(</div><div class="line">	x: <span class="number">0</span>,</div><div class="line">	y: screenH - <span class="number">200</span>,</div><div class="line">	width:screenW,</div><div class="line">	height: <span class="number">200</span>)</div></pre></td></tr></table></figure>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-23-042453.jpg" width="300"><br><br></center>

<p>可以看出来， 子视图被顶部的刘海以及底部的 home 指示区挡住了。我们可以使用 frame 布局或者 auto layout 来优化这个地方:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> insets = <span class="type">UIApplication</span>.shared.delegate?.window??.safeAreaInsets ?? <span class="type">UIEdgeInsets</span>.zero</div><div class="line">            </div><div class="line">view1.frame = <span class="type">CGRect</span>(</div><div class="line">	x: insets.<span class="keyword">left</span>,</div><div class="line">	y: insets.top,</div><div class="line">	width:view.bounds.width - insets.<span class="keyword">left</span> - insets.<span class="keyword">right</span>,</div><div class="line">	height: <span class="number">200</span>)</div><div class="line"></div><div class="line">view2.frame = <span class="type">CGRect</span>(</div><div class="line">	x: insets.<span class="keyword">left</span>,</div><div class="line">	y: screenH - insets.bottom - <span class="number">200</span>,</div><div class="line">	width:view.bounds.width - insets.<span class="keyword">left</span> - insets.<span class="keyword">right</span>,</div><div class="line">	height: <span class="number">200</span>)</div></pre></td></tr></table></figure>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-23-052419.jpg" width="300"><br><br></center>

<p>这样起来好多了,  还有另外一个更好的办法是直接在自定义的 View 中修改 Label 的布局:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">super</span>.layoutSubviews()</div><div class="line">	<span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</div><div class="line">		label.frame = safeAreaLayoutGuide.layoutFrame</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-23-052726.jpg" width="300"><br><br></center>

<p>这样, 不仅仅是在 ViewController 中能够使用 safe area 了。</p>
<h3 id="UIViewController-中的-safe-area"><a href="#UIViewController-中的-safe-area" class="headerlink" title="UIViewController 中的 safe area"></a>UIViewController 中的 safe area</h3><p>在 iOS 11 中 UIViewController 有一个新的属性</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">open <span class="keyword">var</span> additionalSafeAreaInsets: <span class="type">UIEdgeInsets</span></div></pre></td></tr></table></figure>
<p>当 view controller 的子视图覆盖了嵌入的子 view controller 的视图的时候。比如说， 当 UINavigationController 和 UITabbarController 中的 bar 是半透明(translucent) 状态的时候, 就有 <code>additionalSafeAreaInsets</code></p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-24-034928.jpg" width="300"></p>
<p>自定义的 View 上面的 label 布局兼容了 safe area。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UIView</span></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">safeAreaInsetsDidChange</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="comment">//UIViewController</span></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">viewSafeAreaInsetsDidChange</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>这两个方法分别是 UIView 和 UIViewController 的 safe area insets 发生改变时调用的方法，如果需要做一些处理，可以重写这个方法。有点类似于 KVO 的意思。</p>
<h4 id="模拟-iPhone-X-的-safe-area"><a href="#模拟-iPhone-X-的-safe-area" class="headerlink" title="模拟 iPhone X 的 safe area"></a>模拟 iPhone X 的 safe area</h4><p>额外的 safe area insets 也能用来测试你的 app 是否支持 iPhone X。在没有 iPhone X 也不方便使用模拟器的时候， 这个还是很有用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//竖屏</div><div class="line">additionalSafeAreaInsets.top = 24.0</div><div class="line">additionalSafeAreaInsets.bottom = 34.0</div><div class="line"></div><div class="line">//竖屏, status bar 隐藏</div><div class="line">additionalSafeAreaInsets.top = 44.0</div><div class="line">additionalSafeAreaInsets.bottom = 34.0</div><div class="line"></div><div class="line">//横屏</div><div class="line">additionalSafeAreaInsets.left = 44.0</div><div class="line">additionalSafeAreaInsets.bottom = 21.0</div><div class="line">additionalSafeAreaInsets.right = 44.0</div></pre></td></tr></table></figure>
<h3 id="UIScrollView-中的-safe-area"><a href="#UIScrollView-中的-safe-area" class="headerlink" title="UIScrollView 中的 safe area"></a>UIScrollView 中的 safe area</h3><p>在 scroll view 上加一个 label。设置scroll 的约束为:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scrollView.snp.makeConstraints &#123; (make) <span class="keyword">in</span></div><div class="line">    make.edges.equalToSuperview()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-24-064951.jpg" width="300"></p>
<p>iOS 7 中引入 UIViewController 的 <em>automaticallyAdjustsScrollViewInsets</em> 属性在 iOS11 中被废弃掉了。取而代之的是 UIScrollView  的 <em>contentInsetAdjustmentBehavior</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UIScrollViewContentInsetAdjustmentBehavior</span> : <span class="title">Int</span> </span>&#123;    </div><div class="line">    <span class="keyword">case</span> automatic          <span class="comment">//default value</span></div><div class="line">    <span class="keyword">case</span> scrollableAxes</div><div class="line">    <span class="keyword">case</span> never</div><div class="line">    <span class="keyword">case</span> always</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">open <span class="keyword">var</span> contentInsetAdjustmentBehavior: <span class="type">UIScrollViewContentInsetAdjustmentBehavior</span></div></pre></td></tr></table></figure>
<h4 id="Content-Insets-Adjustment-Behavior"><a href="#Content-Insets-Adjustment-Behavior" class="headerlink" title="Content Insets Adjustment Behavior"></a>Content Insets Adjustment Behavior</h4><p><em>never</em> 不做调整。</p>
<p><em>scrollableAxes</em> content insets 只会针对 scrollview 滚动方向做调整。</p>
<p><em>always</em> content insets 会针对两个方向都做调整。</p>
<p><em>automatic</em> 这是默认值。当下面的条件满足时， 它跟 always 是一个意思</p>
<ul>
<li>能够水平滚动，不能垂直滚动</li>
<li>scroll view 是 当前 view controller 的第一个视图</li>
<li>这个controller 是被navigation controller 或者 tab bar controller 管理的</li>
<li><em>automaticallyAdjustsScrollViewInsets</em> 为 true</li>
</ul>
<p>在其他情况下 <em>automoatc</em> 跟 <em>scrollableAxes</em> 一样</p>
<h4 id="Adjusted-Content-Insets"><a href="#Adjusted-Content-Insets" class="headerlink" title="Adjusted Content Insets"></a>Adjusted Content Insets</h4><p>iOS 11 中 UIScrollView 新加了一个属性: <em>adjustedContentInset</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">open <span class="keyword">var</span> adjustedContentInset: <span class="type">UIEdgeInsets</span> &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p><em>adjustedContentInset</em> 和 <em>contentInset</em> 之间有什么区别呢？</p>
<p>在同时有 navigation 和 tab bar 的 view controller 中添加一个 scrollview 然后分别打印两个值:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//iOS 10</span></div><div class="line"><span class="comment">//contentInset = UIEdgeInsets(top: 64.0, left: 0.0, bottom: 49.0, right: 0.0)</span></div><div class="line"><span class="comment">//iOS 11</span></div><div class="line"><span class="comment">//contentInset = UIEdgeInsets(top: 0.0, left: 0.0, bottom: 0.0, right: 0.0)</span></div><div class="line"><span class="comment">//adjustedContentInset = UIEdgeInsets(top: 64.0, left: 0.0, bottom: 49.0, right: 0.0)</span></div></pre></td></tr></table></figure>
<p>然后再设置:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 给 scroll view 的四个方向都加 10 的间距</span></div><div class="line">scrollView.contentInset = <span class="type">UIEdgeInsets</span>(top: <span class="number">10</span>, <span class="keyword">left</span>: <span class="number">10</span>, bottom: <span class="number">10</span>, <span class="keyword">right</span>: <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>打印:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//iOS 10</span></div><div class="line"><span class="comment">//contentInset = UIEdgeInsets(top: 74.0, left: 10.0, bottom: 59.0, right: 10.0)</span></div><div class="line"><span class="comment">//iOS 11</span></div><div class="line"><span class="comment">//contentInset = UIEdgeInsets(top: 10.0, left: 10.0, bottom: 10.0, right: 10.0)</span></div><div class="line"><span class="comment">//adjustedContentInset = UIEdgeInsets(top: 74.0, left: 10.0, bottom: 59.0, right: 10.0)</span></div></pre></td></tr></table></figure>
<p>由此可见，在 iOS 11 中 scroll view 实际的 content inset 可以通过 <em>adjustedContentInset</em> 获取。这就是说如果你要适配 iOS 10 的话。这一部分的逻辑是不一样的。</p>
<p>系统还提供了两个方法来监听这个属性的改变</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UIScrollView</span></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">adjustedContentInsetDidChange</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="comment">//UIScrollViewDelegate</span></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line"><span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidChangeAdjustedContentInset</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></div></pre></td></tr></table></figure>
<h3 id="UITableView-中的-safe-area"><a href="#UITableView-中的-safe-area" class="headerlink" title="UITableView 中的 safe area"></a>UITableView 中的 safe area</h3><p>我们现在再来看一下 UITableView 中 safe area 的情况。我们先添加一个有自定义 header 以及自定义 cell 的 tableview。设置边框为 self.view 的边框。也就是</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tableView.snp.makeConstraints &#123; (make) <span class="keyword">in</span></div><div class="line">	make.edges.equalToSuperview()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tableView.frame = view.bounds</div></pre></td></tr></table></figure>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-23-073208.jpg"></p>
<p>自定义的 header 上面有一个 lable，自定义的 cell 上面也有一个 label。将屏幕横屏之后会发现，cell 以及 header 的布局均自动留出了 safe area 以外的距离。cell 还是那么大，只是 cell 的 contnt view 留出了相应的距离。这其实是 UITableView 中新引入的属性管理的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">open <span class="keyword">var</span> insetsContentViewsToSafeArea: <span class="type">Bool</span></div></pre></td></tr></table></figure>
<p><code>insetsContentViewsToSafeArea</code> 的默认值是 true， 将其设置成 no 之后:</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-24-025524.jpg"></p>
<p>可以看出来 footer 和 cell 的 content view 的大小跟 cell 的大小相同了。这就是说：<strong>在 iOS 11 下, 并不需要改变 header/footer/cell 的布局， 系统会自动区适配 safe area</strong></p>
<p>需要注意的是, Xcode 9 中使用 IB 拖出来的 TableView 默认的边框是 safe area 的。所以实际运行起来 tableview 都是在 safe area 之内的。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-24-live.gif"></p>
<h3 id="UICollectionView-中的-safe-area"><a href="#UICollectionView-中的-safe-area" class="headerlink" title="UICollectionView 中的 safe area"></a>UICollectionView 中的 safe area</h3><p>我们在做一个相同的 collection view 来看一下 collection view 中是什么情况:</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-24-025524.jpg"></p>
<p>这是一个使用了 <code>UICollectionViewFlowLayout</code> 的 collection view。 滑动方向是竖向的。cell 透明， cell 的 content view 是白色的。这些都跟上面 table view 一样。header(UICollectionReusableView) 没有 content view 的概念, 所以给其自身设置了红色的背景。</p>
<p>从截图上可以看出来， collection view 并没有默认给 header cell footer 添加safe area 的间距。能够将布局调整到合适的情况的方法只有将 header/ footer / cell 的子视图跟其 safe area 关联起来。跟 IB 中拖 table view 一个道理。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-24-030448.jpg"></p>
<p>现在我们再试试把布局调整成更像 collection view 那样:</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-24-030732.jpg"></p>
<p>截图上可以看出来横屏下, 左右两边的 cell 都被刘海挡住了。这种情况下, 我们可以通过修改 section insets 来适配 safe area 来解决这个问题。但是再 iOS 11 中， UICollectionViewFlowLayout 提供了一个新的属性 <em>sectionInsetReference</em> 来帮你做这件事情。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UICollectionViewFlowLayoutSectionInsetReference</span> : <span class="title">Int</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> fromContentInset</div><div class="line"></div><div class="line">    <span class="keyword">case</span> fromSafeArea</div><div class="line"></div><div class="line">    <span class="keyword">case</span> fromLayoutMargins</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/// The reference boundary that the section insets will be defined as relative to. Defaults to `.fromContentInset`.</span></div><div class="line"><span class="comment">/// <span class="doctag">NOTE:</span> Content inset will always be respected at a minimum. For example, if the sectionInsetReference equals `.fromSafeArea`, but the adjusted content inset is greater that the combination of the safe area and section insets, then section content will be aligned with the content inset instead.</span></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">open <span class="keyword">var</span> sectionInsetReference: <span class="type">UICollectionViewFlowLayoutSectionInsetReference</span></div></pre></td></tr></table></figure>
<p>可以看出来，系统默认是使用 <code>.fromContentInset</code> 我们再分别修改, 看具体会是什么样子的。 </p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-24-032133.jpg"></p>
<center>fromSafeArea</center>

<p>这种情况下 section content insets 等于原来的大小加上 safe area insets 的大小。</p>
<p>跟使用 <code>.fromLayoutMargins</code> 相似使用这个属性 colection view 的 layout margins 会被添加到 section content insets 上面。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-24-032133.jpg"></p>
<h3 id="IB-中的-Safe-Area"><a href="#IB-中的-Safe-Area" class="headerlink" title="IB 中的 Safe Area"></a>IB 中的 Safe Area</h3><p>前面的例子都说的是用代码布局要实现的部分。但是很多人都还是习惯用 Interface Builder 来写 UI 界面。苹果在 WWDC 2107 Session 412 中提到:<strong>Storyboards 中的 safe area 是向下兼容的</strong> 也就是说, 即使在 iOS10 及以下的 target 中，也可以使用 safe area 来做布局。<strong>唯一需要做的就是给每个 stroyboard 勾选 Use Safe Area Layout Guide</strong>。实际测试看，应该是 iOS9 以后都只需要这么做。</p>
<p><strong>知识点</strong>: 在使用 IB 设置约束之后， 注意看相对的是 superview 还是 topLayoutGuide/bottomLayoutGuide， 包括在 Xcode 9 中勾选了 Use Safe Area Layout Guide 之后，默认应该是相对于 safe area 了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>在适配 iPhone X 的时候首先是要理解 safe area 是怎么回事。盲目的 <code>if iPhoneX{}</code> 只会给之后的工作代码更多的麻烦。</li>
<li>如果只需要适配到 iOS9 之前的 storyboard 都只需要做一件事情。</li>
<li>Xcode9 用 IB 可以看得出来, safe area 到处都是了。理解起来很简单。就是系统对每个 View 都添加了 safe area， 这个区域的大小，是否跟 view 的大小相同是系统来决定的。在这个 View 上的布局只需要相对于 safe area 就可以了。每个 View 的 safe area 都可以通过 iOS 11 新增的 API <strong>safeAreaInsets</strong> 或者 <strong>safeAreaLayoutGuide</strong> 获取。</li>
<li>对与 UIViewController 来说新增了 <strong>additionalSafeAreaInsets</strong> 这个属性, 用来管理有 tabbar 或者 navigation bar 的情况下额外的情况。</li>
<li>对于 UIScrollView， UITableView， UICollectionView 这三个控件来说，系统以及做了大多数的事情。<ul>
<li>scrollView 只需要设置 contentInsetAdjustmentBehavior 就可以很容易的适配带 iPhoneX</li>
<li>tableView 只需要在 cell header footer 等设置约束的时候相对于 safe area 来做</li>
<li>对 collection view 来说修改 <em>sectionInsetReference</em> 为 .safeArea 就可以做大多数的事情了。</li>
</ul>
</li>
<li>总的来说， safe area 可以看作是系统在所有的 view 上加了一个虚拟的 view， 这个虚拟的 view 的大小等都是跟 view 的位置等有关的(当然是在 iPhoneX上才有值) <strong>以后在写代码的时候，自定义的控件都尽量针对 safe area 这个虚拟的 view 进行布局。</strong></li>
</ol>
<p><a href="https://medium.com/rosberryapps/ios-safe-area-ca10e919526f">参考文章</a> 可能需要梯子<br><a href="https://useyourloaf.com/blog/safe-area-layout-guide/">参考文章</a> 可能需要梯子</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 7 之后苹果给 &lt;em&gt;UIViewController&lt;/em&gt; 引入了 &lt;em&gt;topLayoutGuide&lt;/em&gt; 和 &lt;em&gt;bottomLayoutGuide&lt;/em&gt; 两个属性来描述不希望被透明的状态栏或者导航栏遮挡的最高位置(status bar, navigation bar, toolbar, tab bar 等)。这个属性的值是一个 length 属性( &lt;em&gt;topLayoutGuide.length&lt;/em&gt;)。 这个值可能由当前的 ViewController 或者 NavigationController 或者 TabbarController 决定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个独立的ViewController，不包含于任何其他的ViewController。如果状态栏可见，topLayoutGuide表示状态栏的底部，否则表示这个ViewController的上边缘。&lt;/li&gt;
&lt;li&gt;包含于其他ViewController的ViewController不对这个属性起决定作用，而是由容器ViewController决定这个属性的含义：&lt;ul&gt;
&lt;li&gt;如果导航栏（Navigation Bar）可见，topLayoutGuide表示导航栏的底部。&lt;/li&gt;
&lt;li&gt;如果状态栏可见，topLayoutGuide表示状态栏的底部。&lt;/li&gt;
&lt;li&gt;如果都不可见，表示ViewController的上边缘。&lt;br&gt;这部分还比较好理解，总之是屏幕上方任何遮挡内容的栏的最底部。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;iOS 11 开始弃用了这两个属性， 并且引入了 Safe Area 这个概念。苹果建议: &lt;strong&gt;不要把 Control 放在 Safe Area 之外的地方&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// These objects may be used as layout items in the NSLayoutConstraint API&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@available&lt;/span&gt;(iOS, introduced: &lt;span class=&quot;number&quot;&gt;7.0&lt;/span&gt;, deprecated: &lt;span class=&quot;number&quot;&gt;11.0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;open &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; topLayoutGuide: &lt;span class=&quot;type&quot;&gt;UILayoutSupport&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@available&lt;/span&gt;(iOS, introduced: &lt;span class=&quot;number&quot;&gt;7.0&lt;/span&gt;, deprecated: &lt;span class=&quot;number&quot;&gt;11.0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;open &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bottomLayoutGuide: &lt;span class=&quot;type&quot;&gt;UILayoutSupport&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;今天, 来研究一下 iOS 11 中新引入的这个 API。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.CepheusSun.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="iOS11" scheme="http://www.CepheusSun.com/tags/iOS11/"/>
    
  </entry>
  
  <entry>
    <title>Swift4 中的范型约束</title>
    <link href="http://www.CepheusSun.com/Swift4%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B%E7%BA%A6%E6%9D%9F.html"/>
    <id>http://www.CepheusSun.com/Swift4中的范型约束.html</id>
    <published>2017-10-18T16:00:00.000Z</published>
    <updated>2017-10-19T09:58:50.192Z</updated>
    
    <content type="html"><![CDATA[<p>范型可以说是 Swift 跟 OC 相比最大的优势了。通过给像集合这类东西关联范型, 可以写出更可预测并且更安全的代码。在 Swift4 中类型约束更为强大， 它能够让我们更能够轻而易举的做很多事情。即使是通用代码, 也能充分的利用 Swift 的类型系统。</p>
<h2 id="例1"><a href="#例1" class="headerlink" title="例1:"></a>例1:</h2><p>首先我们来看看一个简单的例子。比如说给一个数字数字求和。我们可能会些这样的代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在这段代码中, 我们定义了一个方法, 接受一个 Int 数组作为参数, 在方法内部使用高阶函数 reduce 最后返回这个结果。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(<span class="number">_</span> numbers: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> numbers.<span class="built_in">reduce</span>(<span class="number">0</span>, +)</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line">sum(array) <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>使用范型约束, 我们可以这样来实现这个需求:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在这段代码中, 我们给 Array 添加了类型约束的 Extension。当数组的 Element 遵守了 Numeric 协议的时候, Array 就拥有 sum 这个方法。</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Numeric</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">reduce</span>(<span class="number">0</span>, +)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">array.sum() <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>两者相比, 使用范型约束最大的优势是使用扩展, 能够让这个功能跟调用者更紧密。比较一下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sum = sum(array)</div><div class="line"><span class="keyword">let</span> sum = array.sum()</div></pre></td></tr></table></figure>
<p>在 OC 里面， 可能有些同学会写一个 <code>XXXTool</code> 之类的类, 来封装这种类型的功能。 或者是直接写成 C 的函数。但是不论怎么写,  这样貌似都不是特别的 OOP。或者OC 还可以直接给 NSArray 加一个 category, 然后再实现相似的功能。但是, 这样做不就等于所有的 array 都具有这个功能了吗？</p>
<a id="more"></a>
<h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><p>再来看这样的需求: 计算某个包含字符串集合中有多少个单词。我们可以通过给集合添加一个扩展轻松的完成这件事情。给 <code>Collection</code> 添加一个约束, 限制集合中的 <code>Element</code> 是 <code>String</code>类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span> == <span class="title">String</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">countWords</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">reduce</span>(<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">let</span> components = $<span class="number">1</span>.components(separatedBy: .whitespacesAndNewlines)</div><div class="line">            <span class="keyword">return</span> $<span class="number">0</span> + components.<span class="built_in">count</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> array2 = [<span class="string">"sunny"</span>,<span class="string">"cloudy"</span>,<span class="string">"apple orange"</span>]</div><div class="line">array2.countWords() <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<p>还有一个很酷的做法是约束集合类型中的 <code>Element</code> 是 <code>Closure</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span> ==  () -&gt; <span class="title">Void</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">callAll</span><span class="params">()</span></span> &#123;</div><div class="line">        forEach &#123; $<span class="number">0</span>() &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> closure1 = &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> closure2 = &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> array3 = [closure1, closure2]</div><div class="line">array3.callAll() </div><div class="line"><span class="comment">//1</span></div><div class="line"><span class="comment">//2</span></div></pre></td></tr></table></figure>
<h2 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h2><p>还有一个很好用的特性是使用协议定义 API 的时候。这几乎是写可测试代码以及功能解耦的最佳实践了。需要注意的是, 在需要灵活使用嵌套类型的时候, 这可能会有点麻烦。</p>
<p>看例子吧！我们经常都想要定义一些通用的 API， 来管理程序中的各种 model。这时候肯定会想要定义一个协议:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ModelManager</span> </span>&#123;</div><div class="line">    associatedtype <span class="type">Model</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们再来定一个查找符合某个条件的方法:传入某个查询条件, 然后返回符合这个条件的模型数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ModelManager</span> </span>&#123;</div><div class="line">    associatedtype <span class="type">Model</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">models</span><span class="params">(matching query: String)</span></span> -&gt; [<span class="type">Model</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候， 这个协议变成了这样。这个样子依然有问题，不够灵活, 而且还有一个很恐怖的问题: 硬编码。接下来我们试着使用范型约束来使用 Swift 的类型系统, 让这个功能更灵活, 并且使用类型系统来解决硬编码的问题。</p>
<p>接下来， 再给 <code>ModelManager</code>  关联两个类型， <code>Query</code> 和 <code>Collection</code>。<code>Query</code> 用来描述查询的条件。他可以是任何东西, 只要能够描述查询条件就可以。当然, 个人认为可能 enum 是最好的选择。<code>Collection</code>用来描述查询结果, 他用来限制返回的结果就是这个管理类的模型。现在这个协议就成这样了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ModelManager</span> </span>&#123;</div><div class="line">    associatedtype <span class="type">Model</span></div><div class="line">    associatedtype <span class="type">Collection</span>: <span class="type">Swift</span>.<span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Collection</span>.<span class="type">Element</span> == <span class="type">Model</span></div><div class="line">    associatedtype <span class="type">Query</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">models</span><span class="params">(matching query: Query)</span></span> -&gt; <span class="type">Collection</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了上面的基础, 就可以很方便的实现一些具有查询功能的模型管理类了。比如说我们要用户管理类, 需要通过用户姓名和年龄段来查询符合要求的用户:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义 User 模型</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义 User 管理类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span>: <span class="title">ModelManager</span> </span>&#123;</div><div class="line">    <span class="keyword">typealias</span> <span class="type">Model</span> = <span class="type">User</span></div><div class="line">    <span class="comment">// 查询条件, 姓名或者年龄</span></div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Query</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> name(<span class="type">String</span>)</div><div class="line">        <span class="keyword">case</span> ageRange(<span class="type">Range</span>&lt;<span class="type">Int</span>&gt;)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 查询方法</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">models</span><span class="params">(matching query: Query)</span></span> -&gt; [<span class="type">User</span>] &#123;</div><div class="line">        <span class="comment">// 这里做了几个假的数据</span></div><div class="line">        <span class="keyword">let</span> user1 = <span class="type">User</span>(</div><div class="line">            name: <span class="string">"sunny"</span>,</div><div class="line">            age: <span class="number">25</span>)</div><div class="line">        <span class="keyword">let</span> user2 = <span class="type">User</span>(</div><div class="line">            name: <span class="string">"lily"</span>,</div><div class="line">            age: <span class="number">18</span>)</div><div class="line">        <span class="keyword">let</span> user3 = <span class="type">User</span>(</div><div class="line">            name: <span class="string">"michael"</span>,</div><div class="line">            age: <span class="number">30</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> users = [user1, user2, user3]</div><div class="line">        </div><div class="line">        <span class="keyword">switch</span> query &#123;</div><div class="line">        <span class="keyword">case</span> .name(<span class="keyword">let</span> name):</div><div class="line">            <span class="keyword">return</span> users.<span class="built_in">filter</span>&#123; $<span class="number">0</span>.name == name &#125;</div><div class="line">        <span class="keyword">case</span> .ageRange(<span class="keyword">let</span> range):</div><div class="line">            <span class="keyword">return</span> users.<span class="built_in">filter</span>&#123; range ~= $<span class="number">0</span>.age &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> manager = <span class="type">UserManager</span>()</div><div class="line">manager.models(matching: .name(<span class="string">"sunny"</span>)) <span class="comment">// [&#123;name "sunny", age 25&#125;]</span></div><div class="line">manager.models(matching: .ageRange(<span class="number">10</span> ..&lt; <span class="number">20</span>)) <span class="comment">// [&#123;name "lily", age 18&#125;]</span></div></pre></td></tr></table></figure>
<p>对有些模型来说, 使用字典来作为返回的 <code>Collection</code>可能是更好的方法。下面这个例子是用来通过影片名称和导演名字来筛选电影的例子。返回的结果通过电影分类来做分类。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义电影分类的枚举, 因为要作为字典的 Key 所有需要 Hashable 协议。</span></div><div class="line"><span class="comment">// 使用String 类型的枚举只是为了 hashValue</span></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Genre</span>: <span class="title">String</span>, <span class="title">Hashable</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> cartoon = <span class="string">"cartoon"</span></div><div class="line">    <span class="keyword">case</span> action = <span class="string">"action"</span></div><div class="line">    <span class="keyword">case</span> comedy = <span class="string">"Comedy"</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.rawValue.hashValue</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Genre, rhs: Genre)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> lhs.rawValue == rhs.rawValue</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义电影模型, 因为要作为字典的 Key 所有需要 Hashable 协议。</span></div><div class="line"><span class="comment">// 使用String 类型的枚举只是为了 hashValue</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Movie</span>: <span class="title">Hashable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> director: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> genre: <span class="type">Genre</span></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Int</span>(<span class="string">"<span class="subst">\(name.hashValue)</span>"</span> + <span class="string">"<span class="subst">\(director.hashValue)</span>"</span>)!</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Movie, rhs: Movie)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.director == rhs.director &amp;&amp; lhs.genre == rhs.genre</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieManager</span>: <span class="title">ModelManager</span> </span>&#123;</div><div class="line">    <span class="keyword">typealias</span> <span class="type">Model</span>  = (key: <span class="type">Genre</span>, value: <span class="type">Movie</span>)</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Query</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> name(<span class="type">String</span>)</div><div class="line">        <span class="keyword">case</span> director(<span class="type">String</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">models</span><span class="params">(matching query: Query)</span></span> -&gt; [<span class="type">Genre</span> : <span class="type">Movie</span>] &#123;</div><div class="line">	    <span class="comment">// 方法跟上个例子差不多, 就不实现了</span></div><div class="line">        <span class="keyword">return</span> [:]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用范型约束能够很容易的进行面向协议编程(POP)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;范型可以说是 Swift 跟 OC 相比最大的优势了。通过给像集合这类东西关联范型, 可以写出更可预测并且更安全的代码。在 Swift4 中类型约束更为强大， 它能够让我们更能够轻而易举的做很多事情。即使是通用代码, 也能充分的利用 Swift 的类型系统。&lt;/p&gt;
&lt;h2 id=&quot;例1&quot;&gt;&lt;a href=&quot;#例1&quot; class=&quot;headerlink&quot; title=&quot;例1:&quot;&gt;&lt;/a&gt;例1:&lt;/h2&gt;&lt;p&gt;首先我们来看看一个简单的例子。比如说给一个数字数字求和。我们可能会些这样的代码:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在这段代码中, 我们定义了一个方法, 接受一个 Int 数组作为参数, 在方法内部使用高阶函数 reduce 最后返回这个结果。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; numbers: [Int])&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; numbers.&lt;span class=&quot;built_in&quot;&gt;reduce&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, +)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; array = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sum(array) &lt;span class=&quot;comment&quot;&gt;// 15&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用范型约束, 我们可以这样来实现这个需求:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在这段代码中, 我们给 Array 添加了类型约束的 Extension。当数组的 Element 遵守了 Numeric 协议的时候, Array 就拥有 sum 这个方法。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Array&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Element&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Numeric&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Element&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;reduce&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, +)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;array.sum() &lt;span class=&quot;comment&quot;&gt;// 15&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两者相比, 使用范型约束最大的优势是使用扩展, 能够让这个功能跟调用者更紧密。比较一下:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sum = sum(array)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sum = array.sum()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 OC 里面， 可能有些同学会写一个 &lt;code&gt;XXXTool&lt;/code&gt; 之类的类, 来封装这种类型的功能。 或者是直接写成 C 的函数。但是不论怎么写,  这样貌似都不是特别的 OOP。或者OC 还可以直接给 NSArray 加一个 category, 然后再实现相似的功能。但是, 这样做不就等于所有的 array 都具有这个功能了吗？&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Scrum 实践步骤(摘自:《敏捷革命》)</title>
    <link href="http://www.CepheusSun.com/Scrum%E5%AE%9E%E8%B7%B5%E6%AD%A5%E9%AA%A4(%E6%91%98%E8%87%AA%E3%80%8A%E6%95%8F%E6%8D%B7%E9%9D%A9%E5%91%BD).html"/>
    <id>http://www.CepheusSun.com/Scrum实践步骤(摘自《敏捷革命).html</id>
    <published>2017-10-16T16:00:00.000Z</published>
    <updated>2017-10-17T05:05:49.889Z</updated>
    
    <content type="html"><![CDATA[<p>在现在这家公司带了一段时间了，发现了很多因为流程的不完善, 各个流程之间的衔接的不顺畅带来的”浪费”。加上之前有过的敏捷开发的经验, 和看过的一些想过的资料。又在微信读书上看了《敏捷革命》这本书,  才发现敏捷开发原来是一门非常厉害的学问。在看书的过程中就想着自己总结写一个类似于“破.守.离(先学习规则和形式,  掌握之后再进行创新。最后再特别熟悉的状态下，就可以摆脱形式的束缚，随性发挥。因为一切都已烂熟于心。几乎可以在下意识的状态下做出决定。)”的东西。看到最后就看到了这么一段。</p>
<a id="more"></a>
<ol>
<li><p><strong>挑选一位产品负责人。</strong>这个人必须知道自己带领的团队需要做什么、制造什么产品以及取得什么成果，必须全面考虑到风险与回报、什么具有可行性、什么能做以及他们对什么富有热情。</p>
</li>
<li><p><strong>挑选一个团队。</strong>真正做事的是谁？这个团队必须能够落实产品负责人的愿景。团队规模宜小不宜大，一般3～9人较为合适。</p>
</li>
<li><p><strong>挑选 Scrum 主管。</strong>主管为 Scrum 过程负责，负责培训团队其他成员，确保 Scrum 得到正确运用，帮助团队消除一切障碍。</p>
</li>
<li><p><strong>拟定待办事项清单，并确定优先顺序。</strong>这个清单高屋建瓴地列出为了落实产品负责人的愿景而需要完成的所有事项。在产品的整个研发过程中，这个清单一直存在，并有所演变，相当于产品研发的“路线图”。无论在任何时间，想要知道一个团队要做的所有事项(按照优先顺序排列)，待办事项清单都是唯一具有决定性的参考依据。待办事项清单只有一份，意味着产品负责人从头到尾必须不断地对优先顺序加以调整。产品负责人应该与所有利益相关者和团队进行协商，以确保产品待办事项清单既能反映用户的需求，又不会超出团队的能力范围。</p>
</li>
<li><p><strong>改进和评估待办事项清单。</strong>让负责实际开发工作的团队对待办事项作出评估，是一个至关重要的环节。团队应该审视每个事项，看看是否切实可行。但要完成这些事项，现有的信息足够吗？该项目是否细分到了可以评估的程度？团队是否具有了每个成员都能接受、用于评定一个事项已完成的标准？一个事项能够带来显著的价值？各个事项在完成后必须产生能够用来展示的成果，如果这个成果能够交付给客户试用会更好。不要用所需小时去评估，一位人们根本不擅长做出这么精确的评估。要用相对难度去评估，比如，难度是小、中或大。更好的方式是采用斐波那契数列的数字(1,2,3,5,8,13,21……)。</p>
</li>
<li><p><strong>冲刺规划会。</strong>这是一场 Scrum 会议。团队成员、Scrum 主管以及产品负责人坐到一起，规划冲刺的内容。冲刺周期一般是固定的，不超过一个月，大部分是一至两周。团队要从待办事项的顶端着手(即从最重要的事项着手)，看看一个冲刺阶段中能完成多少。如果团队已经开展过好几个冲刺，那就记录下每个冲刺完成事项的”点数“。这个数字相当于团队的速度。 Scrum 主管与团队成员应努力在每一个冲刺阶段中提高这个数字。团队成员和产品负责人也可以借助“点数”确保每个人都能够了解待办事项对于落实最终愿景的作用。对于冲刺目标，即在这一冲刺阶段完成那些事项，所有人都应形成共识。</p>
<p>​    Scrum 的基石之一在于，产品负责人告诉开发团队他需要完成产品订单中的那些订单项。开发团队决定在下一次冲刺中他们能够承诺完成多少订单项。在冲刺的过程中，没有人能够变更冲刺内容。团队必须在冲刺阶段自主工作。</p>
</li>
<li><p><strong>工作透明化。</strong>在 Scrum 中，最常见的做法是准备一块白板，上面分成三栏：待办事项、在办事项、完成事项。把待办事项写到便签纸上，随着进度的推进，将相应的便签纸转移到其他栏目。</p>
<p>​    让工作透明化的另一个工具是燃尽图。在这张图中，一个轴代表工作量，另一个轴代表时间。每天，Scrum 主管都会记录待完成的剩余点数，而后画在燃尽图。理想的情况下，该图是一条向下的曲线，随着剩余工作的完成，“燃尽”至零。</p>
</li>
<li><p><strong>每日立会。</strong>这是 Scrum 的活力源泉。团队每天在固定时间进行内部沟通，时间一般不超过15分钟，且站立进行，Scrum 主管想团队成员提出下列问题:</p>
<ol>
<li><p>你昨天做了什么去帮助团队完成冲刺？</p>
</li>
<li><p>今天你打算做什么来帮助团队完成冲刺？</p>
</li>
<li><p>什么因素阻碍了团队的前进之路？</p>
</li>
</ol>
</li>
</ol>
<p>​        Scrum主管要问的问题就是这么多！整个会议的内容就是这么多！如果会议时间超过15分钟，那就说明开会的方法存在问题。这样做的意义在于让整个团队清楚地知道在这一个冲刺周期内各项任务的进展。所有任务都能按时完成吗？有没有机会帮助其他团队成员克服障碍？团队的任务都不是自上而下分派的，而是自主决定、自主完成的，也不需要向上司做详细的汇报。Scrum 主管负责消除团队面临的障碍。</p>
<ol>
<li><p><strong>冲刺评估或冲刺展示。</strong>在冲刺结束前，给产品负责人展示成果，也就是展示哪些事项可以挪到“完成事项”那一栏，并且接受评价。这是一场公开的会议，任何人都可以是参与者，不仅仅包括产品负责人、Scrum 主管及开发团队，还包括利益相关者、管理人员与客户。<br>​        团队应该只展示那些符合“完成定义”的事项，也就是全部完成，不需要在做工作就能交付的成果。这个成果或许不是完成的产品，但至少是一项完整的、可以使用的功能。</p>
</li>
<li><p><strong>冲刺回顾。</strong>团队展示之前冲中创造的成果，也就是展示已完成的事项，看看可以为顾客传递哪些价值，并征求反馈意见，大家就会坐下来想想哪些事执行得很顺利，哪些事应该做的更好，以及在下一个冲刺阶段中做出什么改善。那么，如何发现流程中的哪个环节需要改善呢？</p>
<p>​    要让这个冲刺回顾过程有效，团队需要互相信任。必须记住关键的一点，即大家不要从团队中找一个人当成责备对象，而是要将注意力集中在流程上，认真分析一下几个问题：为什么会发生那件事？为什么我们当时忽略了？怎样才能加快工作进度？作为一个团队，大家要集思广益，共同寻求问题解决之道。这一点是至关重要的。</p>
<p>​    于此同时，团队必须有勇气把真正的障碍摆到台面上来，这样做是为了解决问题，而不是为了指责某个成员。团队成员必须能够认真探讨问题，并虚心接受他人反馈的意见和建议，以便寻求问题解决之道，而非只想着为自己辩解。</p>
<p>​    然后就进入了关键环节。团队确定一个最值得改善的地方，将其设定为下一个冲刺阶段的首要任务，当然，改善的结果必须通过“验收测试”。你如何证明自己成功的完成了改善？你需要用具体的、可操作的方式界定什么是“成功”，这样，在下一个冲刺回顾会议中才能很快判断出是否已完成改善。</p>
</li>
<li><p><strong>上一个冲刺阶段结束后，立即开始新的冲刺阶段。</strong>利用在之前的冲刺过程中，团队在消除障碍、改善流程方面积累的经验。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在现在这家公司带了一段时间了，发现了很多因为流程的不完善, 各个流程之间的衔接的不顺畅带来的”浪费”。加上之前有过的敏捷开发的经验, 和看过的一些想过的资料。又在微信读书上看了《敏捷革命》这本书,  才发现敏捷开发原来是一门非常厉害的学问。在看书的过程中就想着自己总结写一个类似于“破.守.离(先学习规则和形式,  掌握之后再进行创新。最后再特别熟悉的状态下，就可以摆脱形式的束缚，随性发挥。因为一切都已烂熟于心。几乎可以在下意识的状态下做出决定。)”的东西。看到最后就看到了这么一段。&lt;/p&gt;
    
    </summary>
    
      <category term="敏捷开发" scheme="http://www.CepheusSun.com/categories/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="读书笔记" scheme="http://www.CepheusSun.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="敏捷开发" scheme="http://www.CepheusSun.com/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>你好！若尔盖</title>
    <link href="http://www.CepheusSun.com/%E4%BD%A0%E5%A5%BD%EF%BC%81%E8%8B%A5%E5%B0%94%E7%9B%96.html"/>
    <id>http://www.CepheusSun.com/你好！若尔盖.html</id>
    <published>2017-10-06T06:02:57.000Z</published>
    <updated>2017-10-07T19:13:39.695Z</updated>
    
    <content type="html"><![CDATA[<p>国庆来了一次说走就走，除了开车很累，还有轻微的高原反应，一切都很好。</p>
<p>一次旅行，还是想到了很多…</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/1769276-623549c6a8bce98a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="红原的牧民家"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1769276-e99cc3ebc8621174.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="花湖"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1769276-e2f6516dadda9c14.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="天空"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1769276-dfa9c5ac1727db9c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="松潘，尕力台大桥"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1769276-4ae9c9f84459574e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="在路上"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1769276-c2ab626a5629dbeb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="貌似是白河"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1769276-cbd39de9355eb7c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="女伴"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1769276-bd52c466ac8c3f33.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="红原的马，黄昏"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1769276-5758663bb051f786.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="我，和我的车"></p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-052546.jpg" alt=""><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-052701.jpg" alt=""></p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-052720.jpg" alt=""></p>
<p>这个时候海拔一直在网上爬。</p>
<p>牦牛就开始多了起来了, 之后沿途都有很多的牦牛。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-052756.jpg" alt=""></p>
<p>原谅我单反玩的不好， 大上午的拍成了这样。我们也不断的要停下车来拍照什么的。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-052902.jpg" alt=""></p>
<p>运气真的很好， 或者是真的季节到了。沿途有好几十公里都是这样的景色。在往前走没多久, 就开始出现草原的。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-053052.jpg" alt=""></p>
<p>第一次看见草原，真的很兴奋。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-053127.jpg" alt=""></p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-054014.jpg" alt=""></p>
<p>这张照片很漂亮, 远处的雪山, 路，云 , 草原。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-054323.jpg" alt=""></p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-054415.jpg" alt=""></p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-054444.jpg" alt=""></p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-054521.jpg" alt=""></p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-054553.jpg" alt=""></p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-10-06-054621.jpg" alt=""></p>
<p>2017年国庆。 成都-成灌、都汶高速-汶川-G213-松潘-G213-若尔盖-S209-红原-G317-马尔康-G317-理县-汶川-成都</p>
<p>这一次，算是圆了草原梦了，一直都很想到草原，到沙漠，到大海。</p>
<p>这一次，也学到了好多东西，至少在地理上面，更清楚哪里是哪里了。</p>
<p>这一趟，毫无压力的挨住了4300的海拔，在4300海拔的地方快跑爬坡，没有什么特别的感觉。以后可以找机会去西藏了。</p>
<p>运气很好，因为前段时间九寨沟地震的缘故，全程交通十分畅通，以至于在213国道上，超速了，6分。还好平时开车稳，在成都几乎不可能违章扣分。</p>
<p>也是因为运气吧，也不叫运气。在松潘的时候下了一场雨。不知道是不是因为这个原因，松潘去若尔盖的路上，遇到了几乎100公里的雪山。很漂亮，特别是配合着雪地里的牦牛。成都全年不下雪，所以很震撼。</p>
<p>路上的风景真的很漂亮，甚至比最终的目的地还要漂亮。这次出门实际上是没有目的地的，出门的时候只是想看看能走多远。然后一不小心就走到了若尔盖。在花湖玩了之后，还想过继续往前走的，走了可能一个小时，想着再往前就是甘肃境内了，当时不知道甘肃有什么好玩的就决定往回走红原了。后来查了下甘南，其实再往前走走还是很有意思的。花湖，因为季节的原因，并没有花，只是里面有一个湖，并没有get到什么，那边路途上湖不多，水到挺多，在Google earth上看湖都离路远。不知道那里是无人区还是怎么样。除了那个湖，就只有草原了，但是沿途基本上都是无穷无尽的草原，所以……</p>
<p>上了高原之后，整个的旅途都是摄影爱好者的天堂，真的是随便一拍都是桌面的感觉。我这种渣渣，都拍到了一些自己还蛮喜欢的照片。</p>
<p>若尔盖到红原，这条路，路况非常好。风景个人觉得比松潘到若尔盖的草原漂亮。但是松潘线上毕竟几十公里雪山，都很喜欢。</p>
<p>准备工作做的不好，所以这次旅行没有尽兴。</p>
<p>自驾游，很给力。就是开车的人很辛苦。这一次全程我自己开车。要是有一个比较信任驾驶技术的老司机同行就好了，可以换着开。在若尔盖，因为太累，都把车停路边睡了半个小时。前一天认床，几乎一夜没睡。</p>
<p>高原土豪真多。骑马的时候跟牧民聊天，他们家最多的时候有2000多头牦牛，几千到一万多一头，随随便便一两千万的家底儿啊。我得写多少代码。</p>
<p>高原也挺落后的，跟我聊天的牧民居然娶了俩媳妇儿，而且当地打女人很正常。想想成都的耙耳朵，唉……</p>
<p>下次想走走康定新都桥这条线，看看能走多远。</p>
<p>有机会还是要走到青海湖。放假前一个月还在考虑要不要去呢？</p>
<p>西藏是一定要去的，川藏线那么美。</p>
<p>下次换车一定换越野，出去玩，还是排量大点的越野得劲儿啊。至少排量要大点啊，1.6的排量，跑起来真的好辛苦。</p>
<p>以后还是要多读书，到松潘的时候，第一想到的居然是松潘黄龙，而不是文成公主。好歹受过高等教育，今年也多多少少关注了一下历史，实在是不应该啊！</p>
<p>以后还是应该带着父母去这些地方，这两年因为老妈太忙可能没机会，看到这样的雪，这样的风景，她肯定会非常兴奋的。</p>
<p>回来之后看到追逐藏羚羊的消息，真的是不知道说什么。旅行，还是应该带着信仰，带着对大自然的敬畏去的。不知道这些人旅行的意义是什么。</p>
<p>本来以为会看到朝拜的人，确实没有这份幸运。网上有人说愚昧，不管怎么样，也应该尊重别人的信仰，他们信仰这些，跟我们信仰科学一样，没有高低之分，信仰是无价的，而大多数中国人缺的就是这个。</p>
<p>很想保护住这些东西，网上看到，青藏高原的冰川消失的速度，实在感到痛心。就跟人的生老病死一样，这件事情让我感觉很无力。要是能好好的保护就好了。</p>
<p>回来之后好好看看余秋雨先生的《山河之书》。</p>
<p>还有一点，一路都在感叹当年红军长征时候的不易。我们还是应该珍惜现在的一切，作为党员，还是觉得我们的干部们都应该去体验一下长征路，好好的想想那些老前辈。党不忘本，党员干部更不应该…</p>
<p>下次去高原应该:</p>
<p>1.带冬天的衣服，毕竟若尔盖全年平均气温只有2度。</p>
<p>2.带唇膏，风吹的嘴巴真的好干。</p>
<p>3.带帐篷睡袋。一个牧民告诉我的，这样确实很酷。</p>
<p>4.红景天，抱着对自己对同伴负责的态度。提前预防高原反应。红原出来在长江黄河分水岭有4300+的海拔，红原3500左右，加上恶劣的气候。虽然只是在青藏高原的边缘。很多人还是会高反的，在红原的酒店遇到了好几个高反的游客。</p>
<p>5.爱护哪里的一草一木，以及可能遇到的牛羊马。</p>
<p>最后了。</p>
<p>很爱旅行，很爱大自然。希望那里一切都好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国庆来了一次说走就走，除了开车很累，还有轻微的高原反应，一切都很好。&lt;/p&gt;
&lt;p&gt;一次旅行，还是想到了很多…&lt;/p&gt;
    
    </summary>
    
      <category term="游记" scheme="http://www.CepheusSun.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="游记" scheme="http://www.CepheusSun.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>半年的远程办公我学到了什么</title>
    <link href="http://www.CepheusSun.com/%E5%8D%8A%E5%B9%B4%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88.html"/>
    <id>http://www.CepheusSun.com/半年的远程办公我学到了什么.html</id>
    <published>2017-08-29T16:00:00.000Z</published>
    <updated>2017-08-30T10:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dev.to/peteranglea/6-months-of-working-remotely-taught-me-a-thing-orten">6 Months of Working Remotely Taught Me a Thing or Ten</a>这篇文章是我在 Twitter 上看到的, 作者自身具有半年的远程开发经历。作为一种还算比较新的团队合作方式, 远程办公这种形式对自身以及团队都有着比较高的要求。我本身对这样的工作方式也非常向往(虽然在目前看来不大可能实现)，但是还是希望能够学到更多有用的东西…</p>
<a id="more"></a>
<p>下面是文章的翻译:</p>
<p>六个月以前, 我入职 Helix Education 这家公司的高级前端工程师。工作内容跟我之前的工作经历基本相同: 制作网页,  写代码, 与作家还有设计师合作。</p>
<p>唯一的区别是我现在是远程办公了。并且, 我跟我的同事们基本上都不在同一个时区。</p>
<p>开始第一份远程办公的工作之前,  我并不知道, 我需要准备些什么东西。在接受这个挑战之前, 我查了很多资料。我还是不确定它会跟别人说的那么好, 还是会给我的工作、学习中带来一场灾难。</p>
<p>但是现在看起来, 远程办公是一把双刃剑。有很多的优点, 也有一些缺点。如果你自己正在远程办公或者打算找一个这样的工作, 下面是我在六个月的时间里总结到了十点经验。</p>
<h3 id="1-让别人随时能找到你"><a href="#1-让别人随时能找到你" class="headerlink" title="1. 让别人随时能找到你"></a>1. 让别人随时能找到你</h3><p>这是我在前辈那里得到最好的经验了。在家办公, 肯定会有很多需要沟通的部分, 如果你什么时候联系不上了, 需要联系到你的那个人的工作就不得不被你给耽误。</p>
<p>只有1分钟的事情，却等了你好几个小时。你就会在你的同事的心中树立”那哥们总是不在”的形象。</p>
<p>远程办公, 就必须要避免给别人留下这种印象。</p>
<p>努力建立起随时都能找到你的形象。及时获取项目最近的状态, 不然你就跟你的同事不同步了。</p>
<p>你们之间可能还会有时差。由于时差的关系, 我的时间比我的同事早了两个小时。如果没有必要强行把时间调整同步的话, 一定要确定别人知道在什么时候能够及时的联系到你。并且确实能够联系到你。利用只有你自己在工作的时间尽可能的高效工作。 这样做, 你才有时间去给其他人沟通。</p>
<h3 id="2-沟通的时候说清楚"><a href="#2-沟通的时候说清楚" class="headerlink" title="2. 沟通的时候说清楚"></a>2. 沟通的时候说清楚</h3><p>远程办公绝大部分的沟通都是通过 Chat Slack， HipChat， text messages 这些方式进行的。跟面对面的沟通不同, 没有了那些语言表达的技巧和面部表情, 很容易出现在理解上的偏差。</p>
<p>除非你和同事之间已经非常了解了, 不要小看<strong>避免理解偏差</strong>这件事情。在你点击发送按钮的时候,  看一下你到底说了什么。确保这些话在不同的心情或者语调下他们的意思不会被误解。</p>
<p>当你们在进行视频会议的时候, 尽可能的简洁。 视频传送过程中偶尔出现的卡顿, 可能会带来一些误解, 或者会被要求重新说一遍。还有就是微笑, <strong>微笑能提升你的颜值哦！ </strong></p>
<h3 id="3-别总是谈工作"><a href="#3-别总是谈工作" class="headerlink" title="3. 别总是谈工作"></a>3. 别总是谈工作</h3><p>花点时间去了解你的同事,  尤其是在加入新的团队的时候。不要每次交流都是在说工作。</p>
<p>跟他们聊聊打招呼, 聊聊天气, 聊聊办公室八卦(但是不要太多管闲事)。因为你不在办公室里面, 所以你也听不到她们在办公室里面的打趣, 或者是那些茶水间谈话。</p>
<p>除非是齐心协力的去做某件事情, 某个同事的生日, 有人离开这个团队, 或者是重要的通知。其他的部分, 你都会错过。</p>
<h3 id="4-多表达正面积极的东西"><a href="#4-多表达正面积极的东西" class="headerlink" title="4. 多表达正面积极的东西"></a>4. 多表达正面积极的东西</h3><p>你还需要去培养出团队协作的感觉。你没办法跟他们一起分享每一件小成功, 但是有一个积极的关系能够让你更轻松的把工作做好。</p>
<p>有些同事可能没有那么频繁的跟你沟通。在这种情况下, 要尽量让他们得到关于你的消息都是正面的。这就又回到了一个事实上:<strong>要积极地去塑造别人对自己的印象, 没有人喜欢一个消极的人。</strong></p>
<h3 id="5-舒适的工作环境能够提高效率"><a href="#5-舒适的工作环境能够提高效率" class="headerlink" title="5. 舒适的工作环境能够提高效率"></a>5. 舒适的工作环境能够提高效率</h3><p>对想远程办公的人来说, 能够在自己喜欢的咖啡厅工作是非常诱人的。但老实说, 这不大现实。在家里的办公桌上, 我的效率是平常的三倍(有三个屏幕, 笔记本 + 两个分屏)。如果需要, 是不是的换一个地方, 但是放弃游牧生活的话, 你会工作的更好。</p>
<p>还有, <strong>不要在卧室工作</strong>。一定要把工作和个人生活分开(在床上躺一会, 这太诱人了)。如果可以的话, 在家里划一个空间出来。不受打扰的工作(尤其是有小孩, 或者是总是打断你注意力的猫),  然后在工作结束之后再出来。</p>
<p>为了避免久坐, 建议去搞一个升降桌。我自己还有一个球椅, 它能够帮助我燃烧卡路里, 保持更健康的姿势, 并且还挺有趣的。</p>
<h3 id="6-穿上裤子工作"><a href="#6-穿上裤子工作" class="headerlink" title="6. 穿上裤子工作"></a>6. 穿上裤子工作</h3><p>另外一个已经远程办公很长时间的朋友告诉我, 上午开始工作之前就要把一切准备好。整理好被子, 梳好头发。穿上衣服(完全穿好-包括裤子) 。 他们通过视频通话只能看见你的脸, 并不代码你能那么自由。</p>
<p>你可以考虑穿的跟在办公室上班一样, 免得别人说你成天穿睡衣上班。在开始工作之前就让自己一切就绪, 能够让你很快的进入工作状态, 也能帮助你战胜惰性思想。</p>
<h3 id="7-多出门"><a href="#7-多出门" class="headerlink" title="7. 多出门"></a>7. 多出门</h3><p>即使你很享受独处,  也要放弃隐士这种倾向。我经常发现我已经好多天没出过门了。</p>
<p>去看看你的信箱(真的那种, btw, 国人貌似看了也没什么意义)。午餐时间出去走走。周末还是要走出去, 即使是帮人跑腿儿。</p>
<p>散步、阳光能对你的工作效率, 精神健康产生奇效。也能让你的思维活泛起来, 说不定什么时候就产生了什么奇效。</p>
<p>跟这个还有点关系的是。每天结束工作之后, 就没在回去接着做了。在远程工作的人来说, 这点很难。 毕竟工作就在你的隔壁房间。但是尽量不要回到办公桌上。每天晚上都列出来一个明天需要完成的工作清单, 然后等到明天说。这也是为什么要在你家里划出单独的空间来工作的原因。</p>
<h3 id="8-多视频交流"><a href="#8-多视频交流" class="headerlink" title="8. 多视频交流"></a>8. 多视频交流</h3><p>一直把自己隔离起来, 只是打打电话, 不可能建立起来正常的人际关系。在跟你交流的时候, 人们需要看见你的脸。有个朋友告诉我, 他从来没有让某个远程员工打开过摄像头, 最后的结果是, 他完全不了解。</p>
<h3 id="9-同时做多个项目"><a href="#9-同时做多个项目" class="headerlink" title="9. 同时做多个项目"></a>9. 同时做多个项目</h3><p>你没看错！ 这听起来像是要你从两头点蜡烛。但是如果是在远程办公的话。你不可能总是能随时找到你的同事。等别人回你消息的时候, 这样才能够随时有事情做。</p>
<p>远程办公，在沟通上肯定是低效的。要在这一点上提前做好准备。</p>
<h3 id="10-利用远程办公的福利-多承担负责"><a href="#10-利用远程办公的福利-多承担负责" class="headerlink" title="10. 利用远程办公的福利, 多承担负责"></a>10. 利用远程办公的福利, 多承担负责</h3><p>我没有说谎。远程办公有很多的福利。这是只有远程办公者特权。跟其他同事相比, 你节约了很多的时间和金钱上的开销。不要去炫耀这些(没人喜欢跟这种人一起工作)。</p>
<p>好好的利用你的空闲时间, 无论是对你自己, 还是对团队都是有好处的。不用每天早上挤1个小时地铁, 你可以比别人多休息一会儿。所以在工作的时候就应该更努力的工作。你也可以利用一部分的时间来阅读, 听听广播, 或者学习。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>远程办公是一项特权。 不一定是最理想的方式, 但是他会带来很大的回报。知道它潜在的风险,  并努力的去弥补这些缺陷。你会变得更高效,  跟同事的关系会更好,  让老板更开心！</p>
<p>好了,  回去工作吧！</p>
<p>别忘了穿裤子哦！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://dev.to/peteranglea/6-months-of-working-remotely-taught-me-a-thing-orten&quot;&gt;6 Months of Working Remotely Taught Me a Thing or Ten&lt;/a&gt;这篇文章是我在 Twitter 上看到的, 作者自身具有半年的远程开发经历。作为一种还算比较新的团队合作方式, 远程办公这种形式对自身以及团队都有着比较高的要求。我本身对这样的工作方式也非常向往(虽然在目前看来不大可能实现)，但是还是希望能够学到更多有用的东西…&lt;/p&gt;
    
    </summary>
    
      <category term="工作方式" scheme="http://www.CepheusSun.com/categories/%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="翻译" scheme="http://www.CepheusSun.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="工作方式" scheme="http://www.CepheusSun.com/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.Codable</title>
    <link href="http://www.CepheusSun.com/Swift4.Codable.html"/>
    <id>http://www.CepheusSun.com/Swift4.Codable.html</id>
    <published>2017-08-28T16:15:23.000Z</published>
    <updated>2017-08-29T07:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>WWDC2017中发布的 Swift4.0 有一个有趣的新特性： Coadble. 今天我们就来聊聊这个 Swift4.0 带来的协议！</p>
<h3 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h3><p>对现在需要随时联网的移动应用来说，把值序列化成能够在硬盘或者通过网络传送的数据是一个基本的需求。但是在苹果的生态中我们的选择很有限。</p>
<a id="more"></a>
<ol>
<li><code>NSCoding</code> 协议提供了对复杂对象的序列化能力，它在自定义类型身上也是有效的。但是，不完善的系列化格式并不适合跨平台的需求, 并且他需要我们手写代码来做编解码的工作。</li>
<li><code>NSPropertyListSerialization</code> 和 <code>NSJSONSerialization</code> 能够让数据能够在 Cocoa 类(NSDictionary/NSString)和属性列表以及 JSON 之间转换。JSON 几乎是所有网络传输的标准格式。由于这些API 只提供了基础类型的转换, 我们必须要编写很多代码从这些值中取出具体类型信息。这些代码通常都是很难复用的，而且这种方式对脏数据的处理能力也不行。</li>
<li><code>NSXMLParser</code> and <code>NSXMLDocument</code> 这种方式是给那些受虐狂，或者是那些深陷 XML 泥潭的人使用的。基本数据和模型对象之间转换的工作还是需要程序员来做。</li>
</ol>
<p>这些方法往往会带来大量的样板代码。声明一个叫做 foo 的 Stirng 属性，这个属性会通过将 String 存储在 foo 下进行编码，并通过检索 foo 这个 key ，找到这个值，然后把它转换成String。如果在其中的某个过程中失败的话，就抛出错误。然后在声明第二个属性…..</p>
<p>程序员当然不可能会喜欢这类重复性的工作。这种工作是计算机做的事情。我们只想要做这样的事情:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Whatevet</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> foo: <span class="type">String</span></div><div class="line">  <span class="keyword">var</span> bar: <span class="type">String</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后他就可以序列化了。这其实是有可能的，毕竟所有必要的信息都有了。</p>
<p>映射是一个很常见的方法，很多 OC 的程序员都写过自动将 JSON 转换成 OC 类型的代码。OC 在运行时能够提供转换需要的所有信息。但是对 Swift 来说呢？ 我们当然也能够使用 OC 的 runtime 或者使用 Swift 的镜像, 然后用一些很奇怪的方法来弥补他在这方面的不足。</p>
<p>在苹果的生态系统之外，这已经是很多语言常见的解决方案了。但是这也可能带来奇怪的安全漏洞。</p>
<p>映射并不是一个很好的解决方案。让他出错并且导致安全问题是很容易的事情。它没有使用静态类型，导致了很多bug都只能在运行时才能暴露出来。并且它的效率也不高，因为它对元数据做了很多的字符串查找。</p>
<p>Swift 采用了编译器代码生成的方法，来做这件事情。这就是说有些内容是被嵌入到编译器种的。但是这样做效率却很高，具备静态类型所有优点的同时，在使用上也不会带来什么麻烦。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Swift 新引入的 Codable 是建立在一些基础协议之上的。</p>
<p><code>Encodable</code> 这个协议用在那些需要被编码的类型上。如果遵守了这个协议，并且这个类的所有属性都是 Encodable 的， 编译器就会自动的生成相关的实现。如果不是，或者说你需要自定义一些东西，就需要自己实现了。</p>
<p><code>Decodable</code>这个协议跟 <code>Encodable</code> 相反，它表示那些能够被解档的类型。跟 <code>Encodable</code> 一样,编译器也会自动为你生成相关的实现，前提是所有属性都是 Decodable 的</p>
<p>由于这两个协议总是一起出现，所以就引入了第三个协议:<code>Codable</code> 。<code>Codable</code>只是把 <code>Decodable</code>  和 <code>Encodable</code> 连到了一起。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">Codable</span> = <span class="type">Decodable</span> &amp; <span class="type">Encodable</span></div></pre></td></tr></table></figure>
<p>这两个协议都很简单。每一个都只有一个实现:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Encodable</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Decodable</span> </span>&#123;</div><div class="line">	<span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个协议说明了对象能够自己编码和解码自己。你不需要去考虑他们的基础用法，因为 <code>Codable</code> 已经给你添加了默认实现的所有细节, 只有在你需要自己实现 Codable 的时候才需要用到他们。这是比较复杂的部分了，后面我们会再说这个问题。</p>
<p>最后，还有一个叫 <code>CodingKey</code> 的协议，用来表示编码和解码的 key。与使用普通的字符串相比，他为程序添加了一个额外的静态类型检查层。他提供了 String 和一个可选的 Int 作为位置键。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CodingKey</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> stringValue: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">	<span class="keyword">init</span>?(stringValue: <span class="type">String</span>)</div><div class="line">	<span class="keyword">var</span> intValue: <span class="type">Int</span>? &#123; <span class="keyword">get</span> &#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">init</span>?(intValue: <span class="type">Int</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>Encoder 和 Decoder 的基本概念跟 NSCoder 类似。对象接受一个编码器然后调用自己的方法来编码或者解码。</p>
<p><code>NSCoder</code> 的API 是很直接的。NSCoder 有一系列像是 <code>encodeObject:forKey</code> 还有<code>encodeInteger:forKey</code>的方法。对象调用他们来完成他们的编码。当然还有一些不需要 key 的方法比如说<code>encodeObject:</code> 和<code>encodeInteger</code> 。他们不需要通过键来定位。</p>
<p>Swift 的 API 就没那么直接了。 Encoder 不提供编码方法而是提供容器，由容器来做编码的工作。一个用于键控编码，一个用于无键编码，一个用来编码单个的值。</p>
<p>这样设计能够让事情更清晰， 也更适合那些便于携带的序列化格式。NSCoder 指需要使用苹果的编码格式，所以放在一起是没有问题的。但是 Encoder 必须使用JSON这一类东西:如果一个对象使用了键编码，就会产生一个 JSON 字典，如果使用的无键编码，产生的就是一个 JSON 数组。但是如果对象是为空，并且没有编码值呢？使用 NSCoder， 是无法知道到底输出什么的。要是使用 <code>Encoder</code> 的话, 对象会请求一个有键容器或者是无键容器这时候编码器就能够从中的值到底需要返回什么了。</p>
<p><code>Decoder</code> 也差不多，我们不直接从中获取解码值，而是通过请求一个容器，从这个容器中获取。跟 <code>Encoder</code> 一样, <code>Decoder</code> 也提供了有键容器、无键容器，还有用来解码单个值的容器。</p>
<p>因为容器这个设计， <code>Encoder</code> 和<code>Decoder</code> 这两个协议就非常的小的。他们只需要少量的信息(路径 info 之类的), 加上一些获取容器的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Encoder</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> codingPath: [<span class="type">CodingKey</span>?] &#123; <span class="keyword">get</span> &#125;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">var</span> userInfo: [<span class="type">CodingUserInfoKey</span> : <span class="type">Any</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">container</span>&lt;Key&gt;<span class="params">(keyedBy type: Key.<span class="keyword">Type</span>)</span></span></div><div class="line">          -&gt; <span class="type">KeyedEncodingContainer</span>&lt;<span class="type">Key</span>&gt; <span class="keyword">where</span> <span class="type">Key</span> : <span class="type">CodingKey</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">unkeyedContainer</span><span class="params">()</span></span> -&gt; <span class="type">UnkeyedEncodingContainer</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">singleValueContainer</span><span class="params">()</span></span> -&gt; <span class="type">SingleValueEncodingContainer</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Decoder</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> codingPath: [<span class="type">CodingKey</span>?] &#123; <span class="keyword">get</span> &#125;</div><div class="line">  <span class="keyword">var</span> userInfo: [<span class="type">CodingUserInfoKey</span> : <span class="type">Any</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">container</span>&lt;Key&gt;<span class="params">(keyedBy type: Key.<span class="keyword">Type</span>)</span></span> <span class="keyword">throws</span></div><div class="line">          -&gt; <span class="type">KeyedDecodingContainer</span>&lt;<span class="type">Key</span>&gt; <span class="keyword">where</span> <span class="type">Key</span> : <span class="type">CodingKey</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">unkeyedContainer</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">UnkeyedDecodingContainer</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">singleValueContainer</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">SingleValueDecodingContainer</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>复杂的部分是在这些容器里面的。你可以通过递归在 Codable 的属性中走到很深的节点。不过，某些时候，我们需要获取可以被编解码的元数据类型。 在 Codable 中这种类型可能是各种 <code>Int</code>、 <code>Float</code> 、<code>Double</code>、 <code>Bool</code> 、<code>String</code>….。这就形成了一整套相似的编解码方法。无键容器也直接支持编码这些类型的序列。</p>
<p>除了这些基本的方法之外，还有一些方法来支持各种不同的使用场景。</p>
<ul>
<li>KeyedDecodingContainer 有个叫做 <code>decodeIfPresent</code> 的方法，这个方法会返回一个 可选类型， 当找不到某个 key 的时候，返回 nil 而不是抛出异常。</li>
<li>编码容器也支持软编码, 只有在其他对象也在编码的时候才会编码。这个可以用来处理一些复杂的父引用。</li>
<li>还有一写方法用来获取嵌套容器，这种容器能够编码不同的层次结构。</li>
<li>最后还有获取 super 编解码器的方法, 这种方法能够让子类和父类在编解码的过程中共存,子类能够直接编码自己, 也能够通过调用父类编码器来编码自己, 唯一的要求是 key 不冲突。</li>
</ul>
<h3 id="实现-Codable"><a href="#实现-Codable" class="headerlink" title="实现 Codable"></a>实现 Codable</h3><p>实现 Codable 是很简单：遵守协议，然后编译器就会自动帮你做剩下的事情了。</p>
<p>要知道它到底干了什么，我们先看看它的最终效果是什么样的，然后再看看如果要自己搞，应该做些什么。我们先看看这个 Codable 的类型:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></div><div class="line">  <span class="keyword">var</span> quest: <span class="type">String</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器会自动生成对应的 key 嵌套在 Person 类中。如果我们自己来做这件事情，这个嵌套类型会是这样的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">CodingKey</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> name</div><div class="line">  <span class="keyword">case</span> age</div><div class="line">  <span class="keyword">case</span> quest</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些枚举对应 Person 类中的各种属性名称。编译器很智能的给每个CodingKey 的值匹配了对应的属性名，这就是说属性名就是归档这个对象所要用的 key 值。</p>
<p>如果我们需要用不同的名称, 只需要提供我们自己的 CodingKey 。像这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>:<span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> name = <span class="string">"person_name"</span></div><div class="line">  <span class="keyword">case</span> age</div><div class="line">  <span class="keyword">case</span> quest</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样写就会让 Person 的 name 属性通过 “person_name”来实现编码和解码。这就是我们需要做的所有事情了。编译器能够很轻松的接受我们自定义的 CodingKey 类型，然后帮你实现 Codable 剩下的部分，并且这些默认的实现支持我们的自定义类型。</p>
<p>编译器同时也生成了 <code>encode(to:)</code> 、<code>init(from:)</code> 相关的实现。 <code>encode(to:)</code> 的实现, 首先获取到有键容器然后挨个去 encode 所有的属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</div><div class="line">  <span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</div><div class="line">  </div><div class="line">  <span class="keyword">try</span> container.encode(name, forKey: .name)</div><div class="line">  <span class="keyword">try</span> container.encode(age, forKey: .age)</div><div class="line">  <span class="keyword">try</span> container.encode(quest, forKey: .quest)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器也会实现 <code>inin(from:)</code> 像是这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</div><div class="line">  <span class="keyword">let</span> container = <span class="keyword">try</span> decoder.container(keyedBy:<span class="type">CodingKeys</span>.<span class="keyword">self</span>)</div><div class="line">  </div><div class="line">  name = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .name)</div><div class="line">  age = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .age)</div><div class="line">  quest = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .quest)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是全部的东西了。就像 CodingKeys 一样, 如果你需要自定义一些具体的行为。你可以自己实现你需要的部分，然后让编译器为你补全剩下的部分。然而，还是没有办法去指定某一个属性的行为，所以，还是需要把所有的属性都实现一边，即使你希望其余的部分都是默认的。不过这应该还好吧！😂</p>
<p>如果你准备自定义所有的过错。Person 类完整的Codable 实现大概是这样的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">CodingKey</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> name</div><div class="line">    <span class="keyword">case</span> age</div><div class="line">    <span class="keyword">case</span> quest</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder:Encoder)</span></span> <span class="keyword">throws</span> &#123;</div><div class="line">	<span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</div><div class="line"></div><div class="line">	<span class="keyword">try</span> container.encode(name, forKey: .name)</div><div class="line">	<span class="keyword">try</span> container.encode(age, forKey: .age)</div><div class="line">	<span class="keyword">try</span> container.encode(quest, forKey: .quest)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</div><div class="line">	<span class="keyword">let</span> container = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</div><div class="line"></div><div class="line">	name = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .name)</div><div class="line">	age = <span class="keyword">try</span> container.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .age)</div><div class="line">	quest = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .quest)</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现-Encoder、-Decoder"><a href="#实现-Encoder、-Decoder" class="headerlink" title="实现 Encoder、 Decoder"></a>实现 Encoder、 Decoder</h3><p>你可能永远都不需要自己实现 <code>Endocer</code> 或者是 <code>Decoder</code>. Swift 已经很好的支持了 JSON、PropertyList。而这两个基本上包含了所有的可能遇见的数据格式。</p>
<p>当然你也可以自己去实现一套来支持你的自定义格式。container  协议的大小说明这需要花点精力，但是这只是大小的问题，而不是增加了什么复杂度。</p>
<p>要实现自定义的 <code>Encoder</code>,  你需要一个实现了 Encoder 协议 同时也要实现容器协议的东西。实现三个容器协议需要大量的模版代码，来实现编解码。</p>
<p>他们具体要怎么做完全是看你了， 编码器可能需要保存正在被编码的的数据，容器需要给编码器提供正在被编码数据的各种信息。</p>
<p>实现自定义的 <code>Decoder</code> 也差不多。你需要在实现这个协议的同时实现容器协议。解码器保存序列化数据，容器跟他通信提供具体的类型信息。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Swift 4 的 Codable 看起来是很强大，他们简化很多代码。对 JSON 来说， 声明对应的模型来遵守 Codable 协议，让后让编译器做剩下的事情，就完全够了。如果需要，你还可以实现这个协议的某一个部分来满足你自己的需求，甚至你还可以完全自己实现。</p>
<p>Encoder 和 Decoder 都很复杂，但是没办法。通过自己实现 Encoder 和 Decoder 来支持一个自定义数据格式需要做一些工作，但这基本上也都是做一些填空题。</p>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2017-07-14-swiftcodable.html">原文地址:Friday Q&amp;A 2017-07-14: Swift.Codable</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WWDC2017中发布的 Swift4.0 有一个有趣的新特性： Coadble. 今天我们就来聊聊这个 Swift4.0 带来的协议！&lt;/p&gt;
&lt;h3 id=&quot;Serialization&quot;&gt;&lt;a href=&quot;#Serialization&quot; class=&quot;headerlink&quot; title=&quot;Serialization&quot;&gt;&lt;/a&gt;Serialization&lt;/h3&gt;&lt;p&gt;对现在需要随时联网的移动应用来说，把值序列化成能够在硬盘或者通过网络传送的数据是一个基本的需求。但是在苹果的生态中我们的选择很有限。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
      <category term="翻译" scheme="http://www.CepheusSun.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS 内存泄漏三两事</title>
    <link href="http://www.CepheusSun.com/iOS%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%89%E4%B8%A4%E4%BA%8B.html"/>
    <id>http://www.CepheusSun.com/iOS 内存泄漏三两事.html</id>
    <published>2017-08-26T16:00:00.000Z</published>
    <updated>2017-08-27T15:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家都有过重写 <code>dealloc</code> 方法来检查某个 view controller 在消失后是否被释放的经历。这几乎是 iOS 中寻找由于引用循环造成内存泄漏最有效的方法了。基本上每次发布，都会做很多次这种事情。不得不说这件事情很无聊，并且很可能会出错。<strong>如果我们在日常的开发中, 提前的学习相关的知识, 那该多好？</strong></p>
<a id="more"></a>
<p>下面是两个很少见的 <code>UIViewController</code>的属性:</p>
<ul>
<li><code>isBeingDismissed</code> 当一个模态推送出来的 view controller 正在消失的时候, 为: true.</li>
<li><code>isMovingFromParentViewController</code> ,当一个 view controller 正在从它的父 view contrlller 中移除的时候(包括从系统的容器试图比如说 UINavigationController), 为true.</li>
</ul>
<p>如果这两个属性有一个是 <code>true</code> 的话, 这个 view controller 就会自动的被释放掉。我们不知道一个 view contrller 完成内部状态的改变，并且被 ARC 释放掉需要耗费多长的时间。为了简单起见，我们假设它不会超过两秒。</p>
<p>1.现在看看下面的代码(文末会有OC版):</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">dch_checkDeallocation</span><span class="params">(afterDelay delay: TimeInterval = <span class="number">2.0</span>)</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> rootParentViewController = dch_rootParentViewController</div><div class="line"></div><div class="line">        <span class="comment">// We don’t check `isBeingDismissed` simply on this view controller because it’s common</span></div><div class="line">        <span class="comment">// to wrap a view controller in another view controller (e.g. in UINavigationController)</span></div><div class="line">        <span class="comment">// and present the wrapping view controller instead.</span></div><div class="line">        <span class="keyword">if</span> isMovingFromParentViewController || rootParentViewController.isBeingDismissed &#123;</div><div class="line">            <span class="keyword">let</span> type = type(of: <span class="keyword">self</span>)</div><div class="line">            <span class="keyword">let</span> disappearanceSource: <span class="type">String</span> = isMovingFromParentViewController ? <span class="string">"removed from its parent"</span> : <span class="string">"dismissed"</span></div><div class="line"></div><div class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay, execute: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">                <span class="built_in">assert</span>(<span class="keyword">self</span> == <span class="literal">nil</span>, <span class="string">"<span class="subst">\(type)</span> not deallocated after being <span class="subst">\(disappearanceSource)</span>"</span>)</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dch_rootParentViewController: <span class="type">UIViewController</span> &#123;</div><div class="line">        <span class="keyword">var</span> root = <span class="keyword">self</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> parent = root.parent &#123;</div><div class="line">            root = parent</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> root</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在延时操作这个闭包中，我们首先通过 <code>[weak self]</code> 来避免这个闭包强引用self。然后通过断言让程序在 <code>self</code> 不为空的时候抛出异常。<strong>只有存在循环引用的情况下这个 view controller 才不为空。</strong></p>
<p>现在我们需要做的就是在 <code>viewDidDisappear</code> 中调用这个方法。只要是你需要检查它在消失后是不是被释放掉的 view controller 都需要添加这个方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidDisappear(animated)</div><div class="line"></div><div class="line">    dch_checkDeallocation()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果发声了内存泄漏，我们就会得到下面的断言:</p>
<p><img src="http://holko.pl/public/images/deallocation_checker@2x.png" alt=""></p>
<p>这个时候，我们只需要打开 Xcode 的 <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/debugging_with_xcode/chapters/special_debugging_workflows.html#//apple_ref/doc/uid/TP40015022-CH9-DontLinkElementID_1">Memory Graph Debugger</a> 找到并且解决这些循环引用。</p>
<ol>
<li>另外在 twitter 上也看到了类似的解决方案。</li>
</ol>
<p><img src="https://pbs.twimg.com/media/DH_nWyhXUAIqByQ.png" alt=""></p>
<p>3.使用国人写的 MLeaksFinder 在每次发生内存泄漏的时候都会弹窗。并且没有代码侵入性，只需要使用 CocosPod 导入就可以了。</p>
<p>4.在使用图片资源的时候，少使用  <code>imageNamed:</code> 方法去获取使用频次不高的图片资源。因为使用 <code>imageNamed:</code>加载的图片资源会一直存在内存里面， 对内存的浪费也是巨大的。</p>
<p>5.上面的方法写了一个 OC 版本的： </p>
<p>.h:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface UIViewController (FindLeaks)</div><div class="line"></div><div class="line"></div><div class="line">// 默认为 NO</div><div class="line">@property (nonatomic) BOOL noCheckLeaks;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>.m:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  UIViewController+FindLeaks.m</div><div class="line">//  Leaks</div><div class="line">//</div><div class="line">//  Created by sunny on 2017/8/27.</div><div class="line">//  Copyright © 2017年 CepheusSun. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;UIViewController+FindLeaks.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">static const char *noCheckLeaksKey = &quot;noChechLeaksKey&quot;;</div><div class="line"></div><div class="line">@interface NSObject (MethodSwizzling)</div><div class="line"></div><div class="line">+ (void)sy_swizzleInstanceSelector:(SEL)origSelector</div><div class="line">                   swizzleSelector:(SEL)swizzleSelector;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation UIViewController (FindLeaks)</div><div class="line"></div><div class="line">#pragma mark - Binding Property</div><div class="line">- (BOOL)noCheckLeaks &#123;</div><div class="line">    return [objc_getAssociatedObject(self, noCheckLeaksKey) boolValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setNoCheckLeaks:(BOOL)noCheckLeaks &#123;</div><div class="line">    objc_setAssociatedObject(self, noCheckLeaksKey, [NSNumber numberWithBool:noCheckLeaks], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Check</div><div class="line">+ (void)load &#123;</div><div class="line">    </div><div class="line">#if DEBUG</div><div class="line">    [self sy_swizzleInstanceSelector:@selector(viewDidDisappear:) swizzleSelector:@selector(fl_viewDidDisappear:)];</div><div class="line">#endif</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fl_viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    [self fl_viewDidDisappear:animated];</div><div class="line">    if (!self.noCheckLeaks) &#123;</div><div class="line">        [self fl_checkDeallocationAfterDelay:2];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fl_checkDeallocationAfterDelay:(NSTimeInterval)delay &#123;</div><div class="line">    UIViewController *root = [self fl_rootParentViewController];</div><div class="line">    if (self.isMovingFromParentViewController || root.isBeingDismissed) &#123;</div><div class="line">        NSString *type = NSStringFromClass([self class]);</div><div class="line">        NSString *disappearanceSource = self.isMovingFromParentViewController ? @&quot;removed from its parent&quot; : @&quot;dismissed&quot;;</div><div class="line">        __weak typeof(self) weakSelf = self;</div><div class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">            NSString *assert = [NSString stringWithFormat:@&quot;%@ not deallocated after being %@&quot;,</div><div class="line">             type, disappearanceSource];</div><div class="line">            NSAssert(weakSelf == nil,assert);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UIViewController *)fl_rootParentViewController &#123;</div><div class="line">    UIViewController *root = self;</div><div class="line">    while (root.parentViewController) &#123;</div><div class="line">        root = root.parentViewController;</div><div class="line">    &#125;</div><div class="line">    return root;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation NSObject (MethodSwizzling)</div><div class="line"></div><div class="line">+ (void)sy_swizzleInstanceSelector:(SEL)origSelector</div><div class="line">                   swizzleSelector:(SEL)swizzleSelector &#123;</div><div class="line">    </div><div class="line">    Method origMethod = class_getInstanceMethod(self, origSelector);</div><div class="line">    Method swizzleMethod = class_getInstanceMethod(self, swizzleSelector);</div><div class="line">    </div><div class="line">    BOOL isAdd = class_addMethod(self, origSelector, method_getImplementation(swizzleMethod), method_getTypeEncoding(swizzleMethod));</div><div class="line">    </div><div class="line">    if (!isAdd) &#123;</div><div class="line">        method_exchangeImplementations(origMethod, swizzleMethod);</div><div class="line">    &#125;else &#123;</div><div class="line">        class_replaceMethod(self, swizzleSelector, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>只需要在不需要检查的方法中设置属性为 YES 就好了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信大家都有过重写 &lt;code&gt;dealloc&lt;/code&gt; 方法来检查某个 view controller 在消失后是否被释放的经历。这几乎是 iOS 中寻找由于引用循环造成内存泄漏最有效的方法了。基本上每次发布，都会做很多次这种事情。不得不说这件事情很无聊，并且很可能会出错。&lt;strong&gt;如果我们在日常的开发中, 提前的学习相关的知识, 那该多好？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.CepheusSun.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://www.CepheusSun.com/tags/Objective-C/"/>
    
      <category term="性能优化" scheme="http://www.CepheusSun.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>一个人的敏捷开发</title>
    <link href="http://www.CepheusSun.com/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91.html"/>
    <id>http://www.CepheusSun.com/一个人的敏捷开发.html</id>
    <published>2017-07-21T16:00:00.000Z</published>
    <updated>2017-07-22T09:41:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-114524.jpg" width="500"></p>
<p>不论是在一些大型的开发团队，还是作为独立开发者。我们经常会被预算、技术迭代，以及时间限制。找到合适的工作方式去适应这些限制, 是所有团队都需要去考虑的问题。</p>
<p><a href="https://www.raywenderlich.com/u/alex_andrews">Alex Andrews</a> 在成立 <a href="http://www.tenkettles.com/">Ten Kettles</a> 的时候花了很多了精力去考虑这个问题。直到有一天上帝把敏捷开发砸到了他的头上，很快他就找到了适合他的敏捷开发之道。他认为敏捷开发极大的解放了他的生产力。</p>
<p>这篇文章就会聊到他是怎么进行敏捷开发的。</p>
<a id="more"></a>
<h2 id="远古时代"><a href="#远古时代" class="headerlink" title="远古时代"></a>远古时代</h2><p>2014年 3月 1 日，是 Ten Kettles 成立的第一天。那时候整个公司只有我一个人，没有流程来遵循。什么时候开始工作，做什么软件，怎么安排任务……. 都由我自己决定。</p>
<p>那时候，我喜欢 free style，虽然有时候会让我不大舒服。早些时候，我在其他公司做搜索工程师, 预估工期是我最自豪的能力: 你给我一个需求，我告诉你什么时候完成，到那个时候，我把代码拿出来。现在做 app 跟那时候是一样的，只不过设计产品的人换了而已，但是知道 2014 年年底，我都还没意识到这点。</p>
<p>后来，我慢慢发现独立开发者这个称呼不是特别准确。因为写代码甚至都不是我现在最主要的工作内容，影响我工作效率的事情不是写代码，而是设计产品。</p>
<p><em>“再加一个功能… “</em></p>
<p><em>”不，这样设计不对… “</em></p>
<p><em>”加载的时候等服务器返回了在进入主界面….”</em></p>
<p>这些想法简直无处不在, 我几乎随时都在考虑这些问题！</p>
<p>这让我的工作效率严重低下。我的音乐类app，远远的超出了计划。虽然最后做出了满意的产品，但是现在回过头去看，总想问自己，为什么那么长的时间却只做了这么点事情？</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-22-060635.jpg" width="500"></p>
<p>结果是很好的，但是过程并不完美。我需要一个更好的工作方式。需要一个能让我更高效，更赚钱，更幸福的工作方式！</p>
<h2 id="哇，敏捷开发"><a href="#哇，敏捷开发" class="headerlink" title="哇，敏捷开发"></a>哇，敏捷开发</h2><p>一直都在重复那些无聊且进展缓慢的工作。我决定给自己一个改变，所以我把精力放在了一些外包工作上面……</p>
<p>知道接触到了一家中等规模的公司, 他们正好在使用敏捷开发来进行项目管理。我开始去了解敏捷开发的, 期望她能够让我更高效的编程。看了很多相关的书或者文章之后，我惊喜的发现敏捷开发触及到了的三个痛点：</p>
<ul>
<li>高产出</li>
<li>高效率</li>
<li>更happy</li>
</ul>
<p>于是，我开始思考在我自己的产品中运用这套理论。</p>
<p>这家公司的项目做完，我去了蒙特利尔, 打算给自己放个假，也仔细的想想怎么让这套理论给我带来效益。我重新看之前的笔记，重新读了两本很好的书，思考了实际情况下的一些问题，最后总结出了改革我的公司的一些办法。</p>
<h2 id="敏捷开发的基本原则"><a href="#敏捷开发的基本原则" class="headerlink" title="敏捷开发的基本原则"></a>敏捷开发的基本原则</h2><p>什么是敏捷开发呢？这里有一段我第一本读到的书中的摘录:</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-124818.jpg" width="500"></p>
<blockquote>
<p>敏捷团队通常由7个左右的人组成，每个任务阶段叫做一个 sprint，包括了回顾和总结的时间。敏捷开发有一个咒语”检察和调整”。敏捷团队具有一个很明显的特征：工作流程和产品在不断的进步。</p>
</blockquote>
<p>独立开发跟 5-9 人的团队开发还是有很多不一样的地方的。这段话讲到的内容跟我使用的敏捷开发还是有一些区别。 我更多的是去定义整个工作流程的一些基本原则.</p>
<p>敏捷开发核心原则:</p>
<ul>
<li><strong>主动变化</strong>。经常把产品给别人体验，无论是最终的用户，测试用户，甚至是一些懂行的朋友。这样可以避免把资源投入到没有必要的功能上。让测试用去去使用 beta 版本的产品，及时根据反馈来调整方向，这样能节约很多的时间。</li>
<li><strong>效率优先，并量化它</strong>。短期内最大的量化指标就是产出，并不是销售或者发版数量。要知道每周完成了多少有效任务, 就需要去量化它。这样才能跟踪进度，并优化它。</li>
<li><strong>自我总结</strong>。定期去回顾总结。</li>
</ul>
<h2 id="如何进行敏捷开发"><a href="#如何进行敏捷开发" class="headerlink" title="如何进行敏捷开发"></a>如何进行敏捷开发</h2><p>知道了敏捷开发的核心原则，那么应该怎么样去实践呢？</p>
<h3 id="Sprint"><a href="#Sprint" class="headerlink" title="Sprint"></a>Sprint</h3><p>就是在固定周期的时间里面完成特定的需求，相当于迭代。在这个 sprint 中你应该把全部的尽力用在完成这些需求上面。</p>
<p>一个 sprint 通常有一到四周，这个由你自己的风格和产品决定。我自己的标准是两周一个 sprint。我觉得这样有足够的时间来完成真正有意义的任务。下面是我的 sprint计划图：</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-22-022732.jpg" width="500"></p>
<p>可以看出来，每个 sprint 中都有很多时间用来做核心的任务，还有一些其他的东西:</p>
<ul>
<li>每日站会 Daily Stand-up Meeting</li>
<li>每周畅想 Weekly Story Time</li>
<li>发布         Sprint Release</li>
<li>敏捷迭代回顾 Sprint Retrospective</li>
<li>敏捷迭代计划 Sprint Plan</li>
</ul>
<h4 id="每日站会（5-min）"><a href="#每日站会（5-min）" class="headerlink" title="每日站会（5 min）"></a>每日站会（5 min）</h4><p>敏捷开发有一个很基础的部分就是自我审查和迭代，尤其是在生产上面。当我们原计划在某一天完成某项任务，但是最后没有完成，这时候就需要总结到底发生了什么，然后在去优化你的工作流。</p>
<p>每日站会是敏捷开发的主要特点。在传统的敏捷开发中，每日站会让每个团队的成员都聊一下昨天的进度，今天的计划和存在的风险。</p>
<ul>
<li>为了简化会议, 避免会议时间太长所以要求大家都站着开这个会。</li>
<li>让所有成员都能跟上节奏，及时暴露出风险和挑战。</li>
</ul>
<p>那一个人怎么搞呢？</p>
<p>我汲取了敏捷开发中的优点。自己总结了一套适合独立开发的每日站会: 拍短片(45 秒) 。</p>
<p>主要是这些内容：</p>
<ul>
<li><p><strong>回顾</strong>：首先看一下昨天的短片，看看昨天定下的任务是什么。</p>
</li>
<li><p><strong>总结</strong>：没有完成昨天的目标？想想为什么没有完成，还有什么地方没有做到更好。是中午开了一个会，耽误了写代码的时间。还是准备 App Store 的截图花的时间超预算了。</p>
</li>
<li><p><strong>准备</strong>：在不到两分钟的时间里，思考一下今天的短片说什么，回答下面的问题：昨天做了什么？今天准备做什么？什么影响了进度。比如这样。</p>
<blockquote>
<p>我昨天我做了 A 的 App Store截图。今天我要写更新日志，然后下午跟一个供应商讨论一下合作。总结：在做截图的时候花了太多的水岸，所以没有完成本来计划的更新日志。下次尝试使用自动化工具。</p>
</blockquote>
</li>
<li><p><strong>拍摄</strong>：拍下这个短片，然后就好了。这些片子在最后的sprint 回顾中还会用到。</p>
</li>
</ul>
<h4 id="每周畅想-（30-45-min）"><a href="#每周畅想-（30-45-min）" class="headerlink" title="每周畅想 （30-45 min）"></a>每周畅想 （30-45 min）</h4><p>在每个 sprint 中，都会花很多的时间去做程序员。很少花时间去考虑公司发展这类东西，要不要做一个新的 App 、大改现在的 app 等灯。<strong>Story Time</strong> 这段时间就是我用来做 CEO 的时间。我建议尽量到其他环境去做这件事情，咖啡店什么的。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-22-033948.jpg" width="500"></p>
<p>在 Story Time ，我会去整理一下从用户那里收到的反馈，考虑今后加什么功能，考虑怎么运营 app 和公司。然后把一些实际的想法加到一个列表里面我叫它需求池。</p>
<p>需求池里面都是一些比较大的任务。它帮助我计划下一个 sprint。所以在 Store Time 中也需要去修改和整理需求池。比如:</p>
<p>在统计中看到了更多巴西方面的东西，这就是说，你可能需要加入葡萄牙语，而不是原计划的西班牙语。或者可能看到了一些用户希望的小功能。这时候也需要考虑是不是把这个需求加入这个列表。</p>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>敏捷开发还有个原则就是要让你做的工作能够产出成品。这就是在 Sprint Release 中需要做的事情。不一定需要是一个完整的 app，但是把这段时间的工作拿给其他人试一下也是很重要的。让测试用户体验，从他们那儿得到一些反馈。</p>
<p>在敏捷开发的过程中，发布的范围会逐渐的扩大。比如说，最开始你可能只需要发布一个只有一两个新功能的 beta 版。这时候可以优先的去考虑最重要的功能，这样能够尽快的拿到测试反馈。如果你的测试用户根本都没有提到过某个功能，这就是说这没那么重要。这也能帮你决定下个 sprint 中任务的优先级。</p>
<h4 id="Last-Day-of-the-Sprint"><a href="#Last-Day-of-the-Sprint" class="headerlink" title="Last Day of the Sprint"></a>Last Day of the Sprint</h4><p>已经花了9天来完成这个 sprint 的目标，终于到了最后一天了。这一天可能是最轻松的一天，因为今天可能不需要做开发工作。今天是用来回顾这个 sprint，计划下一个 sprint 的一天，然后还可以休息休息。</p>
<p>这可能会让人觉得奇怪，在截止日期做这样的事情？上学的时候，我经常会在回家的路上看书。但是这样我会走偏方向，然后摔倒。敏捷开发也一样，如果不经常抬头看看方向，可能方向就错了。</p>
<p>确保方向正确，这就是 sprint 最后一天做的事情。这是一整天，或者是在是时间紧迫，半天也可以。这一天，抬头看看周围，确保做的事最重要的事情。因为即便你非常的高产出，在不重要的事情上花时间也是不值得的。</p>
<p>现在来看看这天要做什么吧！</p>
<h5 id="Retrospective-回顾-（小于2h）"><a href="#Retrospective-回顾-（小于2h）" class="headerlink" title="Retrospective(回顾) （小于2h）"></a>Retrospective(回顾) （小于2h）</h5><p>打开一个新的文档，或者是在笔记本上翻开新的一页，写下你对刚刚过去的两个星期的总结。这是你发现是什么阻碍你的效率的好机会。</p>
<p>这写是一些简单的问题：</p>
<ul>
<li>我完成了什么？</li>
<li>我达成了我 sprint 的目标了吗？</li>
<li>这个 sprint 最的好的是什么？还有什么地方可以做到更好？</li>
<li>有什么影响效率的因素？回顾每天的短片来找到这个问题的答案。</li>
<li>有什么没什么必要的事情让你焦虑了，或者让你觉得很爽？</li>
</ul>
<p>如果你发现出去走走比在桌子边上回顾，那就出去走走吧！然后回来迅速的写下你的总结。我发现这样确实更有效果。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-22-033938.jpg"  width="500"></p>
<h5 id="Sprint-计划-（小于2h）"><a href="#Sprint-计划-（小于2h）" class="headerlink" title="Sprint 计划 （小于2h）"></a>Sprint 计划 （小于2h）</h5><p>在回顾两次 Story Time 和需求池之间，你应该好好想想下一个 sprint 要做什么。把需求池整理一下，然后挑几个最重要的！</p>
<p>下面是一个简单的例子。说你现在有个快完成了的 app ，你计划下个 sprint 加入最后一个功能，然后做一些自测工作，最后把 Beta 版发布出去。在你的计划文档中，就是下面的内容：</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-22-045041.jpg" width="500"></p>
<p>在两个星期的 sprint 中，可能还会有更多的任务需要完成。这只是简单的举个例子。</p>
<p>看每个任务后面的数字，这些都是任务评分。比如说，一个 1 分的任务，需要花 2 分任务一半的时间去完成。这个标准需要你自己来定。就我来说，我还是喜欢用1，2，3，5，8这样的数字，这样可以纠正我们低估大任务的倾向。没有4，所以我必须得用5这个数字。</p>
<p>当你完成所有任务的时候，去想想每一个任务相对于其他的任务需要花费的时间。冷静下来，去预测每一项任务需要花费的时间。</p>
<p>如果某一项任务很复杂，但是你已经做过很多次了，那就可以少估计一点时间，也就是说可以减少这个分值。如果某个任务很简单，但是你还不熟悉。就可以多估计一点时间，也就是加点这个分值。</p>
<p>当你完成任务的时候，只需要把所有分值都加起来，然后跟上个 sprint 做一个比较。如果你经常得到 80-100分的总分，那么下个 sprint 的总分应该就差不多是80的样子了。</p>
<p>这可以说是敏捷开发中最有效的事情了，也是我任务最难做的一部分了，我经常发现，我总是减少我想做的事情的评分，给重要的任务更多的评分。有了 sprint 计划，就擦掉你上个 sprint 的任务板，然后为下个 sprint 做准备！</p>
<p>什么是任务板(Task Board)呢？</p>
<blockquote>
<p>译者: 在之前的敏捷开发实践中，都会有一个白板，清晰的写上这些东西。下个部分会讲到。</p>
</blockquote>
<h4 id="任务板"><a href="#任务板" class="headerlink" title="任务板"></a>任务板</h4><p>现在我们就来说说任务板。即使我在我的笔记本或者其他地方已经了我这个 sprint 的计划，我每天的任务还是会在任务板上组织。我把这个任务板放在办公室的墙上。上面会写一些东西，主要是：<strong>TODO</strong>、<strong>DOING</strong>、<strong>DONE</strong>。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-22-051037.jpg" width="500"></p>
<p>每天下班的之前，我都把第二天的任务写在一个便签上，然后把它们贴在TODO这一块。假如我上个 sprint 平均每天拿到了10分，我就会给下一天贴上10分的任务。</p>
<p>第二天早上，我就会把 <strong>TODO</strong> 上的第一个便签拿到 <strong>DOING</strong> 这边。这样做能够让我更容易集中精力。</p>
<p>任务完成的时候，把这个便签拿到 <strong>DONE</strong> 这边。看到 <strong>DONE</strong> 越来越多，是一件很有成就感的事情。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-22-051624.jpg" width="500"></p>
<h4 id="Rest-and-Explore"><a href="#Rest-and-Explore" class="headerlink" title="Rest and Explore"></a>Rest and Explore</h4><p>回到 sprint 中间来。现在你到了 sprint 的最后一个下午了。这个下午就好好的放松一下吧！我经常都是坐在沙发上，看看 Raywenderlich.com 上的教程，或者学点新的知识。</p>
<p>不要把这件事情当作例行工作那样做。只需要做一些跟工作有关，由能让你放松的工作。喝一杯饮料，听听音乐，庆祝庆祝这个 sprint 你完成的工作，多好！</p>
<h2 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h2><p>对独立开发者来说选择正确的工作方式是很个人的事情。这跟你的精力相关。同时也需要要激励你，让你成长。以这个为核心原则，就能够找到适合你自己的敏捷开发之道了。</p>
<p>额外的建议：</p>
<ul>
<li>在刚刚开始的时候，不要因为实际完成的任务比计划完成的任务差很多而感到不好。在下个 sprint 中调整就好了。不断的调整正是敏捷开发的意义。</li>
<li>每隔一两天就调整一下这个 sprint 的计划。review 每一个任务，调整他的分值。如果分值变得很高，就需要把一些低优先级的任务移除掉了。</li>
<li>计划细节是一件很麻烦的事情。如果你跟我一样也是两周一个 sprint。第二个星期的计划没有那么详细也是可以的。每天的调整能够慢慢的丰富它。</li>
<li>对公司来说，有一个长期计划是必要的，但是不要死咬住这个计划不放。保持一个流动的需求池来适应改变。</li>
<li>即便这是我在做 Ten Kettles 的 app 的时候总结的东西。他们在做外包的时候也是很好用的这只需要做一些很小的改动。比如说任务板，可能就需要做成虚拟的了，这样才能让甲方知道你现在是什么情况。</li>
<li>别样了买马克笔还有标签纸。</li>
</ul>
<p>我第一次意识到作为独立开发者，我需要更好的工作方式的时候，我想到了三个需求。更高效的产出，从 app 中获得更多的收入，更多的幸福感。我也很高兴这样的改变确实带来了这些东西。app 的迭代频率大大的上升，每个月的平均收入增长了 18%，用户也更满意(在 App Store中平均分 4.75)，而且工作和生活找到了更好的平衡点。有了周末，一切都更好了。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这是一篇最近的采访，关于我最近在 Ten Kettles 的的细节。</p>
<p>记住下面三个敏捷开发的基本原则</p>
<ul>
<li>主动改变</li>
<li>效率优先</li>
<li>不断的总结</li>
</ul>
<p>看起来很简单，但是有很好工作流程，这几点能够明显的影响你的工作。</p>
<p>如果你想要学习更多关于敏捷开发，尤其是在团队中的敏捷开发的话，这有一些资料。</p>
<p>我最开始看的两本书是：</p>
<ul>
<li><a href="https://www.amazon.com/Scrum-Doing-Twice-Work-Half/dp/038534645X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1495477992&amp;sr=1-1&amp;keywords=scrum+art+of+doing">Scrum: The Art of Doing Twice the Work in Half the Time (Sutherland, Sutherland)</a></li>
<li><a href="https://www.amazon.com/Scrum-Breathtakingly-Brief-Agile-Introduction/dp/193796504X">Scrum: a Breathtakingly Brief and Agile Introduction (Sims, Johnson)</a></li>
</ul>
<p><strong>这篇文章翻译自Ray wenderlich <a href="https://www.raywenderlich.com/162654/scrum-one-bring-scrum-one-person-operation">Scrum Of One: How to Bring Scrum into your One-Person Operation</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ocg4av0wv.bkt.clouddn.com/2017-07-21-114524.jpg&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;不论是在一些大型的开发团队，还是作为独立开发者。我们经常会被预算、技术迭代，以及时间限制。找到合适的工作方式去适应这些限制, 是所有团队都需要去考虑的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.raywenderlich.com/u/alex_andrews&quot;&gt;Alex Andrews&lt;/a&gt; 在成立 &lt;a href=&quot;http://www.tenkettles.com/&quot;&gt;Ten Kettles&lt;/a&gt; 的时候花了很多了精力去考虑这个问题。直到有一天上帝把敏捷开发砸到了他的头上，很快他就找到了适合他的敏捷开发之道。他认为敏捷开发极大的解放了他的生产力。&lt;/p&gt;
&lt;p&gt;这篇文章就会聊到他是怎么进行敏捷开发的。&lt;/p&gt;
    
    </summary>
    
      <category term="敏捷开发" scheme="http://www.CepheusSun.com/categories/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="翻译" scheme="http://www.CepheusSun.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="敏捷开发" scheme="http://www.CepheusSun.com/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>用 ReSwift 实现 Redux 架构</title>
    <link href="http://www.CepheusSun.com/ReSwiftAndRedux.html"/>
    <id>http://www.CepheusSun.com/ReSwiftAndRedux.html</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-07-21T11:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着 app 的发展， MVC 渐渐的满足不了业务的需求。大家都在探索各种各样的架构模式来适应这种情况，像是MVVM、VIPER、<a href="https://eng.uber.com/new-rider-app/">Riblets</a> 等等。 他们都有各自的特点，但是都有同一个核心: 通过多向数据流将代码按照单一职责原则来划分代码。在多向数据流中，数据在各个模块中传递。</p>
<p>多向数据流并不一定是你想要的，反而，单向数据流才是我们更喜欢的数据传递方式。在这个 ReSwift 的教程中，你会学到如何使用 ReSwift 来实现单向数据流，并完成一个状态驱动的游戏——<strong>MemoryTunes</strong></p>
<a id="more"></a>
<h2 id="什么是-ReSwift"><a href="#什么是-ReSwift" class="headerlink" title="什么是 ReSwift"></a>什么是 ReSwift</h2><p><a href="https://github.com/ReSwift/ReSwift">ReSwift</a> 是一个轻量级的框架，能够帮助你很轻松的去构建一个 Redux 架构的app。当然它是用Swift 实现的。</p>
<p>RxSwift 有以下四个模块</p>
<ul>
<li><strong>Views</strong>： 响应 <strong>Store</strong> 的改变，并且把他们展示在页面上。views 发出 <strong>Actions</strong>。</li>
<li><strong>Actions</strong>:发起app 种状态的改变。Action 是有 <strong>Reducer</strong> 操作的。</li>
<li><strong>Reducers</strong>: 直接改变程序的状态，这些状态由 <strong>Store</strong> 来保存。</li>
<li><strong>Store</strong>:保存当前的程序的状态。其他模块，比如说 <strong>Views</strong> 可以订阅这个状态，并且响应状态的改变。</li>
</ul>
<p>ReSwift 至少有以下这些优势:</p>
<ul>
<li><strong>很强的约束力</strong>：把一些代码放在不合适的地方往往具有很强的诱惑性，虽然这样写很方便。ReSwift 通过很强的约束力来避免这种情况。</li>
<li><strong>单向数据流</strong>：多向数据流的代码在阅读和debug上都可能变成一场灾难。一个改变可能会带来一系列的连锁反应。而单向数据流就能让程序的运行更加具有可预测性，也能够减少阅读这些代码的痛苦。</li>
<li><strong>容易测试</strong>：大多数的业务逻辑都在Reducer 中，这些都是纯的功能。</li>
<li><strong>复用性</strong>：ReSwift 中的每个组件—Store、Reducer、Action ，都是能在各个平台独立运行的，可以很轻松的在iOS、macOS、或者tvOS 中复用这些模块。</li>
</ul>
<h3 id="多向数据流-vs-单向数据流"><a href="#多向数据流-vs-单向数据流" class="headerlink" title="多向数据流 vs. 单向数据流"></a>多向数据流 vs. 单向数据流</h3><p>通过以下的几个例子，我们来理解一下什么是数据流。一个基于 VIPER 架构实现的程序就允许数据在其组件中多向传递。</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-20-033011.jpg" alt="VIPER 中的多向数据流"><br><br>VIPER 中的多向数据流</center>

<p>跟 ReSwift 中的数据传递方向比较一下：</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-20-033331.jpg" alt=""><br><br>ReSwift 中的单向数据流</center>

<p>可以看出来，数据是单向传递的，这么做，可以让程序中的数据传递更加清晰，也能够很轻松的定位到问题的所在。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>这是一个已经把整个框架差不多搭建起来的模版项目，包含了一些骨架代码，和库。<a href="https://github.com/CepheusSun/Translate/tree/master/demos/ReSwiftAndRedux">GitHub</a></p>
<p>首先需要做一些准备工作，首先就是要设置这个app最重要的部分:state</p>
<p>打开<strong>AppState.swift</strong> 文件，创建一个 AppState 的结构体:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppState</span> : <span class="title">StateType</span></span>&#123;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个结构体定义了整个app的状态。</p>
<p>在创建包含所有的 AppState 的 <strong>Store</strong> 之前，还要创建一个主 Reducer</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-20-034323.jpg" alt=""><br><br></center>

<p>Reducer 是唯一可以直接改变 <strong>Store</strong> 中 <strong>AppState</strong> 的值的地方。只有 Action 可以驱动 Reducer 来改变当前程序的状态。而 Reducer 改变当前 AppState 的值，又取决于他接受到的 Action 类型。</p>
<blockquote>
<p>注意，在程序中只有一个 Store， 他也只有一个主 Reducer</p>
</blockquote>
<p>接下来在<strong>AppReducer.swift</strong> 中创建主 reducer：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">appReducer</span><span class="params">(action: Action, state: AppState?)</span></span> -&gt; <span class="type">AppState</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">AppState</span>()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>appReducer</strong> 是一个接收 Action 并且返回改变之后的 AppState 的函数。参数 state 是程序当前的 state。 这个函数可以根据他接收的 Action 直接改变这个 状态。现在就可以很容易的创建一个 AppState 值了。</p>
<p>现在应该创建 Store 来保存 state 了。</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-20-035231.jpg" alt=""><br><br></center>

<p>Store 包含了整个程序当前的状态：这是 AppState 的一个实例。打开<strong>AppDelegate.swift</strong> ,在 impore UIkit 下面添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="keyword">var</span> store = <span class="type">Store</span>&lt;<span class="type">AppState</span>&gt;(reducer: appReducer, state: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>这段代码通过 appReducer 创建了一个全局的变量store，appReducer 是这个 Store 的主 Reducer，他包含了接收到action的时候，store 应该怎么改变的规则。因为这是一些准备工作，所以只是传递了一个 nil state 进去。</p>
<p>编译运行，当然，什么都看不见。因为还没写啊！</p>
<h2 id="App-Routing"><a href="#App-Routing" class="headerlink" title="App Routing"></a>App Routing</h2><p>现在可以创建第一个实质的 state了，可是使用 IB 的导航，或者是 routing。</p>
<p>App 路由在所有的架构模式中都是一个挑战，在 ReSwift 中也是。在 MemoryTunes 中将使用很简单的方法来做这件事情，首先需要通过 enum 定义所有的终点，然后让 AppState 持有当前的终点。AppRouter 就会响应这个值的改变，达到路由的目的。</p>
<p>在 <strong>AppRouter.swift</strong> 中添加下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RoutingDestination</span>: <span class="title">String</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> menu = <span class="string">"MenuTableViewController"</span></div><div class="line">  <span class="keyword">case</span> categories = <span class="string">"CategoriesTableViewController"</span></div><div class="line">  <span class="keyword">case</span> game = <span class="string">"GameViewController"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个枚举代表了app 中的所有 ViewController。</p>
<p>到现在，终于有能够放在你程序状态中的数据了。在这个例子里面，只有一个 state 结构体(AppState), 你也可以在这个 state 里面通过子状态的方法，将状态进行分类，这是一个很好的实践。</p>
<p>打开 <strong>RoutingState.swift</strong> 添加如下的子状态结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RoutingState</span>: <span class="title">StateType</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> navigationState: <span class="type">RoutingDestination</span></div><div class="line">  </div><div class="line">  <span class="keyword">init</span>(navigationState: <span class="type">RoutingDestination</span> = .menu) &#123;</div><div class="line">    <span class="keyword">self</span>.navigationState = navigationState</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RoutingState 包含了 navigationState， 这个东西，就是当前屏幕展示的界面。</p>
<blockquote>
<p>menu 是 navigationState 的默认值。如果没有制定的话，将它设置成这个app的最初状态。</p>
</blockquote>
<p>在 <strong>AppState.swift</strong> 中，添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> routingState: <span class="type">RoutingState</span></div></pre></td></tr></table></figure>
<p>现在 AppState 就有了 RoutingState 这个子状态。编译一下，会发现一个错误。</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-20-091710.jpg" alt=""><br><br></center>

<p><em>appReducer</em> 编译不过了！因为我们给 <em>AppState</em> 添加了 <em>routingState</em>，但是在初始化的时候并没有把这个东西传进去。现在还需要一个 reducer 来创建 <em>routingState</em></p>
<p>现在我们只有一个主 <strong>Reducer</strong>， 跟 state 类型，我们也可以通过 子Reducer 来将 Reducer 划分开来。</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-014930.jpg" alt=""><br><br></center>

<p>在 <strong>RoutingReducer.swift</strong> 中添加下面的 <strong>Reducer</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">routingReducer</span><span class="params">(action: Action, state: RoutingState?)</span></span> -&gt; <span class="type">RoutingState</span> &#123;</div><div class="line">  <span class="keyword">let</span> state = state ?? <span class="type">RoutingState</span>()</div><div class="line">  <span class="keyword">return</span> state</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟 主 Reducer 差不多， <em>routionReducer</em> 根据接收到的 Action 改变状态，然后将这个状态返回。到现在，还没有创建 action 所以如果没有接收到 state 的话，就 new 一个 <em>RoutingState</em>，然后返回。</p>
<p>子 reducer 负责创造他们对应的 子状态。</p>
<p>现在回到 <strong>AppReducer.swift</strong> 去改变这个编译错误:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="type">AppState</span>(routingState: routingReducer(action: action, </div><div class="line">										 state: state?.routingState))</div></pre></td></tr></table></figure>
<p>给 AppState 的初始化方法中添加了对应的参数。其中的 action 和 state 都是由main reducer 传递进去的。</p>
<h3 id="订阅-subscribing"><a href="#订阅-subscribing" class="headerlink" title="订阅  subscribing"></a>订阅  subscribing</h3><p>还记得 RoutingState 里面那个默认的 state <code>.menu</code> 吗？他就是 app 默认的状态。只是你还没有订阅它。</p>
<p>任何的类都可以定于这个 store， 不仅仅是 <strong>View</strong>。当一个类订阅了这个 Store 之后，每次 state 的改变他都会得到通知。我们在 <em>AppRouter</em> 中订阅这个 Store， 然后收到通知之后，push 一个 Controller</p>
<p>打开 <strong>AppRouter.swift</strong> 然后重新写 <em>AppRouter</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRouter</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">let</span> navigationController: <span class="type">UINavigationController</span></div><div class="line">  </div><div class="line">  <span class="keyword">init</span>(window: <span class="type">UIWindow</span>) &#123;</div><div class="line">    navigationController = <span class="type">UINavigationController</span>()</div><div class="line">    window.rootViewController = navigationController</div><div class="line">    </div><div class="line">    <span class="comment">// 1</span></div><div class="line">    store.subscribe(<span class="keyword">self</span>) &#123;</div><div class="line">      $<span class="number">0</span>.select &#123;</div><div class="line">        $<span class="number">0</span>.routingState</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 2</span></div><div class="line">  fileprivate <span class="function"><span class="keyword">func</span>  <span class="title">pushViewController</span><span class="params">(identifier: String, animated: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> viewController = instantiateViewController(identifier: identifier)</div><div class="line">    navigationController.pushViewController(viewController, animated: animated)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  fileprivate <span class="function"><span class="keyword">func</span> <span class="title">instantiateViewController</span><span class="params">(identifier: String)</span></span> -&gt; <span class="type">UIViewController</span> &#123;</div><div class="line">    <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="literal">nil</span>)</div><div class="line">    <span class="keyword">return</span> storyboard.instantiateViewController(withIdentifier: identifier)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MARK: - StoreSubscriber</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppRouter</span> :<span class="title">StoreSubscriber</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">newState</span><span class="params">(state: RoutingState)</span></span> &#123;</div><div class="line">    <span class="comment">// 4</span></div><div class="line">    <span class="keyword">let</span> shouldsAnimate = navigationController.topViewController != <span class="literal">nil</span></div><div class="line">    pushViewController(identifier: state.navigationState.rawValue, animated: shouldsAnimate)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这段代码中，我们改了 AppRouter 这个类，然后添加了一个 extension。我们看看具体每一步都做了什么吧！</p>
<ol>
<li><em>AppState</em> 现在订阅了全局的 store， 在闭包里面， selct 表明正在订阅 routingState 的改变。</li>
<li><em>pushViewController</em> 用来初始化，并且 push 这个控制器。通过 identifier 加载的 StoryBoard 中的控制器。</li>
<li>让 <em>AppRouter</em> 响应 StoreSubscriber， 当 routingState 改变的时候，将新的值返回回来。</li>
<li>根控制器是不需要动画的，所以在这个地方判断一下根控制器。</li>
<li>当 state 发生改变，就可以去出 state.navigationState, push 出对应的 controller</li>
</ol>
<p>AppRouter 现在就就初始化 <em>menu</em> 然后将 <em>MenuTableViewController</em> push 出来</p>
<p>编译运行：</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-024808.jpg" width="200"><br><br></center>

<p>现在 app 中就是 <em>MenuTableViewController</em> 了, 现在当然还是空的。毕竟我们还没有开始学 view。</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-025205.jpg" alt=""><br><br></center>

<p>任何东西都可能是一个 <em>StoreSubscriber</em>， 但是大多数情况下都是 view 层在响应状态的变化。现在是让 <em>MenuTableViewController</em> 来展示两个不同的 menu 了。</p>
<p>去 <strong>MenuState.swift</strong>， 创建对应的 Reducer</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MenuState</span>: <span class="title">StateType</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> menuTitles: [<span class="type">String</span>]</div><div class="line">  </div><div class="line">  <span class="keyword">init</span>() &#123;</div><div class="line">    menuTitles = [<span class="string">"NewGame"</span>, <span class="string">"Choose Category"</span>]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>MenuState</strong> 有一个 *menuTitles， 这个属性就是 tableView 的 title</p>
<p>在 <strong>MenuReducer.swift</strong> 中，创建这个 state 对应的 Reducer:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">menuReducer</span><span class="params">(action: Action, state: MenuState?)</span></span> -&gt; <span class="type">MenuState</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">MenuState</span>()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 MenuState 是静态的，所以不需要去处理状态的变化。所以这里只需要简单的返回一个新的 MenuState</p>
<p>回到 <strong>AppState.swift</strong> 中, 添加</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> meunState: <span class="type">MenuState</span></div></pre></td></tr></table></figure>
<p>编译又失败了，然后需要到 <strong>AppReducer.swift</strong> 中去修改这个编译错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="type">AppState</span>(routingState: routingReducer(action: action,</div><div class="line">                                  state: state?.routingState),</div><div class="line">      meunState: menuReducer(action: action, state: state?.meunState))</div></pre></td></tr></table></figure>
<p>现在有了 MenuState, 接下来就是要订阅它了。</p>
<p>先在打开 <strong>MenuTableViewController.swift</strong>, 然后将代码改成这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuTableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">var</span> tableDataSource: <span class="type">TableDataSource</span>&lt;<span class="type">UITableViewCell</span>, <span class="type">String</span>&gt;?</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewWillAppear(animated)</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    store.subscribe(<span class="keyword">self</span>) &#123;</div><div class="line">      $<span class="number">0</span>.select &#123;</div><div class="line">        $<span class="number">0</span>.menuState</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewWillDisappear(animated)</div><div class="line">    <span class="comment">// 3</span></div><div class="line">    store.unsubscribe(<span class="keyword">self</span>)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MARK: - StoreSubscriber</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MenuTableViewController</span>: <span class="title">StoreSubscriber</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">newState</span><span class="params">(state: MenuState)</span></span> &#123;</div><div class="line">    <span class="comment">// 4</span></div><div class="line">    tableDataSource = <span class="type">TableDataSource</span>(cellIdentifier: <span class="string">"TitleCell"</span>, models: state.menuTitles) &#123;</div><div class="line">      $<span class="number">0</span>.textLabel?.text = $<span class="number">1</span></div><div class="line">      $<span class="number">0</span>.textLabel?.textAlignment = .center</div><div class="line">      <span class="keyword">return</span> $<span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    tableView.dataSource = tableDataSource</div><div class="line">    tableView.reloadData()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们来看看这段代码做了什么？</p>
<ol>
<li>TableDataSource 包含了UITableView data source 相关的东西。</li>
<li>订阅了 menuState</li>
<li>取消订阅</li>
<li>这段代码就是实现 UITableView 的代码，在这儿可以很明确的看到 state 是怎么变成 view 的。</li>
</ol>
<blockquote>
<p>可能已经发现了，ReSwift 使用了很多值类型变量，而不是对象类型。并且推荐使用声明式的 UI 代码。为什么呢？</p>
<p>StoreSubscriber 中定义的 newState 回调了状态的改变。你可能会通过这样的方法去接货这个值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuTableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">&gt;   <span class="keyword">var</span> currentMenuTitlesState: [<span class="type">String</span>]</div><div class="line">&gt;   ...</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>但是写声明式的 UI 代码，可以很明确的知道 state 是怎么转换成 View 的。在这个例子中的问题的 UITableView 并没有这样的API。这就是我写 TableDataSource 来桥接的原因。如果你感兴趣的话可以去看看这个 <strong>TableDataSource.swift</strong></p>
</blockquote>
<p>编译运行，就能够看到了:</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-032618.jpg" width="200"><br><br></center>

<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-032930.jpg" alt=""><br><br></center>

<p>做好了 View 接下来就来写 <strong>Action</strong> 了。</p>
<p>Action 是 Store 中数据改变的原因。一个 Action 就是一个有很多变量结构体，这写变量也是这个 Action 的参数。 Reducer 处理一系列的 action， 然后改变 app 的状态。</p>
<p>我们现在先创建一个 Action， 打开 <strong>RoutingAction.swift</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RoutingAction</span>: <span class="title">Action</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> destination: <span class="type">RoutingDestination</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>RoutingAction</em> 改变当前的 routing 终点</p>
<p>现在，当 menu 的 cell 被点击的时候，派发一个 action。</p>
<p>在 <strong>MenuTableViewController.swift</strong> 中添加下面的代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> routeDestination: <span class="type">RoutingDestination</span> = .categories</div><div class="line">    <span class="keyword">switch</span> indexPath.row &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>: routeDestination = .game</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>: routeDestination = .categories</div><div class="line">    <span class="keyword">default</span>:<span class="keyword">break</span></div><div class="line">    &#125;</div><div class="line">    store.dispatch(<span class="type">RoutingAction</span>(destination: routeDestination))</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这段代码，根据选择的 cell 设置不同的 routeDestination 然后用dispatch 方法派发出去。</p>
<p>这个 action 被派发出去了，但是，还没有被任何的 reducer 给支持。现在去 RoutingReducer.swift 然后做一下对应的修改。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> state = state ?? <span class="type">RoutingState</span>()</div><div class="line"></div><div class="line"><span class="keyword">switch</span> action &#123;</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> routingAction <span class="keyword">as</span> <span class="type">RoutingAction</span>:</div><div class="line">  state.navigationState = routingAction.destination</div><div class="line"><span class="keyword">default</span>: <span class="keyword">break</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> state</div></pre></td></tr></table></figure>
<p>switch 语句用来判断是否传入的 action 是 RoutingAction。如果是，就修改 state 为这个 action 的 destination</p>
<p>编译运行，现在点击 item ， 就会对应的 push 出 controller。</p>
<h2 id="Updating-the-State"><a href="#Updating-the-State" class="headerlink" title="Updating the State"></a>Updating the State</h2><p>这样去实现导航可能是由瑕疵的。当你点击 “New Game” 的时候，<code>RoutingState</code> 的 <code>navigationState</code> 就会从<code>menu</code> 变成 <code>game</code>。 但是当你点击 controller 的返回按钮的时候，navigationState 却没有改变。</p>
<p>在 ReSwift 中，让状态跟 UI 同步是很重要的，但是这又是最容易搞忘的东西。特别是向上面那样，由 UIKit 自动控制的东西。</p>
<p>我们可以在 MenutableViewController 出现的时候更新一下这个状态。</p>
<p>在 <strong>MenuTableViewController.swift</strong> 的 <code>viewWillAppear</code>: 方法中，添加:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="type">RoutingAction</span>(destination: .menu))</div></pre></td></tr></table></figure>
<p>这样就能够在上面的问题出现的时候解决这个问题。</p>
<p>运行一下呢？呃… 完全乱了。也可能会看到一个崩溃。</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-live.gif" alt=""><br><br></center>

<p>打开 <strong>AppRouter.swift</strong>， 你会看到每次接收到一个新的 navigationState 的时候，都会调用 <code>pushViewController</code> 方法。也就是说，每次响应就会 push 一个 menu 出来！</p>
<p>所以我们还必须在 push 之前确定这个 controller 是不是正在屏幕中。所以我们修改一下 <code>pushViewController</code>  这个方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fileprivate <span class="function"><span class="keyword">func</span>  <span class="title">pushViewController</span><span class="params">(identifier: String, animated: Bool)</span></span> &#123;</div><div class="line">	<span class="keyword">let</span> viewController = instantiateViewController(identifier: identifier)</div><div class="line">    <span class="keyword">let</span> newViewControllerType = type(of: viewController)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> currentVc = navigationController.topViewController &#123;</div><div class="line">      <span class="keyword">let</span> currentViewControllerType = type(of: currentVc)</div><div class="line">      <span class="keyword">if</span> currentViewControllerType == newViewControllerType &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    navigationController.pushViewController(viewController, animated: animated)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法中，通过 <code>type(of:)</code> 方法来避免当前的 topViewController 跟 要推出来的 Controller 进行对比。如果相等，就直接 <code>return</code> 。</p>
<p>编译运行，这时候，又一切正常了。</p>
<p>当 UI 发生变化的时候更新当前的状态是比较复杂的事情。这是写 ReSwift 的时候必须要解决的一件事情。还好他不是那么常见。</p>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>现在，我们继续来实现  <em>CategoriesTableViewController</em> 这一部分跟之前的部分比起来更复杂一些。这个界面需要允许用户来选择音乐的类型，首先，我们在<strong>CategoriesState.swift</strong> 中添加响应的状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Category</span>: <span class="title">String</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> pop = <span class="string">"Pop"</span></div><div class="line">  <span class="keyword">case</span> electrinic = <span class="string">"Electronic"</span></div><div class="line">  <span class="keyword">case</span> rock = <span class="string">"Rock"</span></div><div class="line">  <span class="keyword">case</span> metal = <span class="string">"Metal"</span></div><div class="line">  <span class="keyword">case</span> rap = <span class="string">"Rap"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CategoriesState</span>: <span class="title">StateType</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> categories: [<span class="type">Category</span>]</div><div class="line">  <span class="keyword">var</span> currentCategorySelected: <span class="type">Category</span></div><div class="line">  </div><div class="line">  <span class="keyword">init</span>(currentCategory: <span class="type">Category</span>) &#123;</div><div class="line">    categories = [.pop, .electrinic, .rock, .metal, .rap]</div><div class="line">    currentCategorySelected = currentCategory</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个枚举定义了一些音乐的类型。CategoriesState 包含了一个数组的种类，以及当前选择的种类。</p>
<p>在 <strong>ChangeCategoryAction.swift</strong> 中添加这些代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChangeCategoryAction</span>: <span class="title">Action</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> categoryIndex: <span class="type">Int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里定义了对应的 action， 使用 categoryIndex 来寻找对应的音乐类型。</p>
<p>现在来实现 Reducer了。 这个 reducer 需要接受 ChangeCategoryAction 然后将新的 state 保存起来。打开 <strong>CategoryReducer.swift</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">CategoriesReducerConstants</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">let</span> userDefaultCategoryKey = <span class="string">"currentCategoryKey"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> <span class="type">C</span> = <span class="type">CategoriesReducerConstants</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">categoriesReducer</span><span class="params">(action: Action, state: CategoriesState?)</span></span> -&gt; <span class="type">CategoriesState</span> &#123;</div><div class="line">  <span class="keyword">var</span> currentCategory: <span class="type">Category</span> = .pop</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">if</span> <span class="keyword">let</span> loadedCategory = getCurrentCategoryStateFromUserDefaults() &#123;</div><div class="line">    currentCategory = loadedCategory</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> state = state ?? <span class="type">CategoriesState</span>(currentCategory: currentCategory)</div><div class="line">  </div><div class="line">  <span class="keyword">switch</span> action &#123;</div><div class="line">  <span class="keyword">case</span> <span class="keyword">let</span> changeCategoryAction <span class="keyword">as</span> <span class="type">ChangeCategoryAction</span>:</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">let</span> newCategory = state.categories[changeCategoryAction.categoryIndex]</div><div class="line">    state.currentCategorySelected = newCategory</div><div class="line">    saveCurrentCategoryStateToUserdefaults(category: newCategory)</div><div class="line">  <span class="keyword">default</span>: <span class="keyword">break</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> state</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">getCurrentCategoryStateFromUserDefaults</span><span class="params">()</span></span> -&gt; <span class="type">Category</span>?</div><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> userDefaults = <span class="type">UserDefaults</span>.standard</div><div class="line">  <span class="keyword">let</span> rawValue = userDefaults.string(forKey: <span class="type">C</span>.userDefaultCategoryKey)</div><div class="line">  <span class="keyword">if</span> <span class="keyword">let</span> rawValue = rawValue &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Category</span>(rawValue: rawValue)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 4</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">saveCurrentCategoryStateToUserdefaults</span><span class="params">(category: Category)</span></span> &#123;</div><div class="line">  <span class="keyword">let</span> userDefaults = <span class="type">UserDefaults</span>.standard</div><div class="line">  userDefaults.<span class="keyword">set</span>(category.rawValue, forKey: <span class="type">C</span>.userDefaultCategoryKey)</div><div class="line">  userDefaults.synchronize()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟其他的 Reducer 一样，这些方法实现了一下比较复杂的状态的改变，并且将选择之后的状态通过 Userdefault 持久化。</p>
<ol>
<li>从 UserDefault 中获取 category， 然后赋值给 CategoriesState</li>
<li>在接收到 ChangeCategoryAction 的时候更新状态，然后保存下来</li>
<li>从 Userdefault 中获取state</li>
<li>将 state 保存在 UserDefault 中</li>
</ol>
<p>3、4 中的两个方法都是功能很单一的方法，而且是全局的。你也可以把他们放在一个类或者结构体中。</p>
<p>接下来很自然的，就会需要在 AppState 中添加新的状态。打开 <strong>AppState.swift</strong> 然后添加对应的状态:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> categoriesState: <span class="type">CategoriesState</span></div></pre></td></tr></table></figure>
<p>然后去 <strong>AppReducer.swift</strong> 中去修改对应的错误</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="type">AppState</span>(routingState: routingReducer(action: action,</div><div class="line">                                             state: state?.routingState),</div><div class="line">                meunState: menuReducer(action: action, state: state?.meunState),</div><div class="line">      categoriesState: categoriesReducer(action: action, state: state?.categoriesState))</div></pre></td></tr></table></figure>
<p>现在还需要 View 了。现在需要在 CategoriesViewController 中去写这部分的 View</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoriesTableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> tableDataSource: <span class="type">TableDataSource</span>&lt;<span class="type">UITableViewCell</span>, <span class="type">Category</span>&gt;?</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewWillAppear(animated)</div><div class="line">    <span class="comment">//1</span></div><div class="line">    store.subscribe(<span class="keyword">self</span>) &#123;</div><div class="line">      $<span class="number">0</span>.select &#123;</div><div class="line">        $<span class="number">0</span>.categoriesState</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidDisappear(animated)</div><div class="line">    store.unsubscribe(<span class="keyword">self</span>)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    store.dispatch(<span class="type">ChangeCategoryAction</span>(categoryIndex: indexPath.row))</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CategoriesTableViewController</span>: <span class="title">StoreSubscriber</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">newState</span><span class="params">(state: CategoriesState)</span></span> &#123;</div><div class="line">    tableDataSource = <span class="type">TableDataSource</span>(cellIdentifier: <span class="string">"CategoryCell"</span>, models: state.categories) &#123;</div><div class="line">      $<span class="number">0</span>.textLabel?.text = $<span class="number">1</span>.rawValue</div><div class="line">      <span class="comment">// 3</span></div><div class="line">      $<span class="number">0</span>.accessoryType = (state.currentCategorySelected == $<span class="number">1</span>) ? .checkmark : .<span class="keyword">none</span></div><div class="line">      <span class="keyword">return</span> $<span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    tableView.dataSource = tableDataSource</div><div class="line">    tableView.reloadData()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分的代码跟 MenuTableViewController 差不多。注释中标记的内容分别是：</p>
<ol>
<li>在 <code>viewWillAppear</code> 中订阅 categoriesState 的改变，然后在 <code>viewillDisappear</code> 中取消订阅。</li>
<li>将事件派发出去</li>
<li>标记选择的状态</li>
</ol>
<p>所有的东西都写好了，现在试一下！</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-065609.jpg" width="200"><br><br></center>

<h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>怎么都跑不了这个话题，这在 ReSwift 也很方便。</p>
<p>场景:从 iTunes的 <a href="https://affiliate.itunes.apple.com/resources/documentation/itunes-store-web-service-search-api/?uo=8&amp;at=11ld4k">API</a> 中去获取照片。首先需要创建对应的 state， reducer 以及相关的 action.</p>
<p>打开 <strong>GameState.swift</strong> 添加</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GameState</span>: <span class="title">StateType</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> memoryCards: [<span class="type">MemoryCard</span>]</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">var</span> showLoading: <span class="type">Bool</span></div><div class="line">  <span class="comment">// 2</span></div><div class="line">  <span class="keyword">var</span> gameFinishied: <span class="type">Bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码定义了 Game 的状态。</p>
<ol>
<li>loading 的 菊花，是否存在</li>
<li>游戏是否结束</li>
</ol>
<p>接下来是Reducer <strong>GameReducer.swift</strong>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">gameReducer</span><span class="params">(action: Action, state: GameState?)</span></span> -&gt; <span class="type">GameState</span> &#123;</div><div class="line">  <span class="keyword">let</span> state = state ?? <span class="type">GameState</span>(memoryCards: [],</div><div class="line">                                 showLoading: <span class="literal">false</span>,</div><div class="line">                                 gameFinishied: <span class="literal">false</span>)</div><div class="line">  <span class="keyword">return</span> state</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码就是简单的创建了一个 <em>GameState</em>, 稍后会再回到这个地方的。</p>
<p>在 <strong>AppState.swift</strong> 中，添加对应的状态</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> gameState: <span class="type">GameState</span></div></pre></td></tr></table></figure>
<p>修改 <strong>AppReducer.swift</strong> 中出现的编译错误</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="type">AppState</span>(routingState: routingReducer(action: action,</div><div class="line">                                               state: state?.routingState),</div><div class="line">                  meunState: menuReducer(action: action, state: state?.meunState),</div><div class="line">                  categoriesState: categoriesReducer(action: action, state: state?.categoriesState),</div><div class="line">                  gameState: gameReducer(action: action, state: state?.gameState))</div></pre></td></tr></table></figure>
<blockquote>
<p>发现了规律了吧，在每次写完 Action/Reducer/State之后应该做什么都是可见并且很简单的。这种情况，得益于ReSwift 的单向数据特效和严格的代码约束。只有 Reducer 能够改变 app 的 Store，只有 Action 能够触发这种响应。这样做能够让你知道在上面地方找代码，在什么地方做新功能。</p>
</blockquote>
<p>现在开始定义 Action， 这个 action 用来更新卡片。在 <strong>SetCardsAction.swift</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SetCardsAction</span>: <span class="title">Action</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> cardImageUrls: [<span class="type">String</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 action 用来设置 GameState 中图片的URL</p>
<p>现在开始准备程序中第一个异步行为吧！在 <strong>FetchTumesAction.swift</strong> 中，添加下面的代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchTunes</span><span class="params">(state: AppState, store: Store&lt;AppState&gt;)</span></span> -&gt; <span class="type">FetchTunesAction</span> &#123;</div><div class="line">  iTunesAPI.searchFor(category: state.categoriesState.currentCategorySelected.rawValue) &#123;</div><div class="line">    store.dispatch(<span class="type">SetCardsAction</span>(cardImageUrls: $<span class="number">0</span>))</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="type">FetchTunesAction</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FetchTunesAction</span>: <span class="title">Action</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><code>fetchTunes</code>  通过 <code>itunesAPI</code> 获取了图片。然后在闭包中将结果派发出来。 ReSwift 中的异步任务就是这么简单。</p>
<p><code>fetchTunes</code> 返回一个 <code>FetchTunesAction</code>  这个 action 是用来验证请求的。</p>
<p>打开 <strong>OpenReducer.swift</strong> 然后添加对这两个 action 的支持。把 <code>gameReducer</code> 中的代码改成下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> state = state ?? <span class="type">GameState</span>(memoryCards: [],</div><div class="line">                                showLoading: <span class="literal">false</span>,</div><div class="line">                                gameFinishied: <span class="literal">false</span>)</div><div class="line"> <span class="keyword">switch</span> action &#123;</div><div class="line"> <span class="comment">// 1</span></div><div class="line"> <span class="keyword">case</span> <span class="number">_</span> <span class="keyword">as</span> <span class="type">FetchTunesAction</span>:</div><div class="line">   state = <span class="type">GameState</span>(memoryCards: [],</div><div class="line">                     showLoading: <span class="literal">true</span>,</div><div class="line">                     gameFinishied: <span class="literal">false</span>)</div><div class="line"> <span class="comment">// 2</span></div><div class="line"> <span class="keyword">case</span> <span class="keyword">let</span> setCardsAction <span class="keyword">as</span> <span class="type">SetCardsAction</span>:</div><div class="line">   state.memoryCards = generateNewCards(with: setCardsAction.cardImageUrls)</div><div class="line">   state.showLoading = <span class="literal">false</span></div><div class="line"> <span class="keyword">default</span>:<span class="keyword">break</span></div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> state</div></pre></td></tr></table></figure>
<p>这段代码，就是根据具体的 action 做不同的事情。</p>
<ol>
<li>FetchTunesAction, 设置 showLoading 为 true</li>
<li>SetCardsAction, 打乱卡片，然后将 showLoading 设置为 false。 generateNewCards 方法可以在 <strong>MemoryGameLogic.swift</strong> 中找到</li>
</ol>
<p>现在开始写 <strong>View</strong></p>
<p>在 <strong>CardCollectionViewCell.swift</strong> 中添加下面的方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">configCell</span><span class="params">(with cardState: MemoryCard)</span></span> &#123;</div><div class="line">  <span class="keyword">let</span> url = <span class="type">URL</span>(string: cardState.imageUrl)</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  cardImageView.kf.setImage(with: url)</div><div class="line">  <span class="comment">// 2</span></div><div class="line">  cardImageView.alpha = cardState.isAlreadyGuessed || cardState.isFlipped ? <span class="number">1</span> : <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>configCell</code> 这个方法做了下面两件事情:</p>
<ol>
<li>使用 Kingfisher 来缓存图片</li>
<li>判断是否展示图片</li>
</ol>
<p>下一步，实现 CollectionView。在 gameViewCotroller.swift 倒入 <code>import ReSwift</code> 然后在 <code>showGameFinishedAlert</code> 上面添加下面的代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> collectionDataSource: <span class="type">CollectionDataSource</span>&lt;<span class="type">CardCollectionViewCell</span>, <span class="type">MemoryCard</span>&gt;?</div><div class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">   <span class="keyword">super</span>.viewWillAppear(animated)</div><div class="line">   store.subscribe(<span class="keyword">self</span>) &#123;</div><div class="line">     $<span class="number">0</span>.select &#123;</div><div class="line">       $<span class="number">0</span>.gameState</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">   <span class="keyword">super</span>.viewWillDisappear(animated)</div><div class="line">   store.unsubscribe(<span class="keyword">self</span>)</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">   <span class="comment">// 1</span></div><div class="line">   store.dispatch(fetchTunes)</div><div class="line">   collectionView.delegate = <span class="keyword">self</span></div><div class="line">   loadingIndicator.hidesWhenStopped = <span class="literal">true</span></div><div class="line">   </div><div class="line">   <span class="comment">// 2</span></div><div class="line">   collectionDataSource = <span class="type">CollectionDataSource</span>.<span class="keyword">init</span>(cellIdentifier: <span class="string">"CardCell"</span>, models: []) &#123;</div><div class="line">     $<span class="number">0</span>.configCell(with: $<span class="number">1</span>)</div><div class="line">     <span class="keyword">return</span> $<span class="number">0</span></div><div class="line">   &#125;</div><div class="line">   collectionView.dataSource = collectionDataSource</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>由于没有写 StoreSubscriber ，所以这里会有一点点的编译错误。我们先假设已经写了。这段代码，首先是订阅了取消订阅 gameState 然后:</p>
<ol>
<li>派发 fetchTunes 来获取图片</li>
<li>使用 CollectiondataSource  来配置 cell 相关信息。</li>
</ol>
<p>现在我们来添加 <code>StoreSubscriber</code> :</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">GameViewController</span>: <span class="title">StoreSubscriber</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">newState</span><span class="params">(state: GameState)</span></span> &#123;</div><div class="line">    collectionDataSource?.models = state.memoryCards</div><div class="line">    collectionView.reloadData()</div><div class="line">    <span class="comment">// 1</span></div><div class="line">    state.showLoading ? loadingIndicator.startAnimating() : loadingIndicator.stopAnimating()</div><div class="line">       <span class="comment">// 2</span></div><div class="line">    <span class="keyword">if</span> state.gameFinishied &#123;</div><div class="line">      showGameFinishedAlert()</div><div class="line">      store.dispatch(fetchTunes)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码实现了 state 改变的时候对应的变化。他会更新 dataSource</p>
<ol>
<li>更新 loading indicator 的状态。</li>
<li>当游戏结束时，弹窗</li>
</ol>
<p>现在，运行一下吧！</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-085643.jpg" width="200"><br><br></center>

<h2 id="Play"><a href="#Play" class="headerlink" title="Play"></a>Play</h2><p>游戏的逻辑是： 让用户翻转两张卡片的时候，如果它们是一眼的，就让他们保持，如果不一样就翻回去。用户的任务是在尽可能少的尝试之后翻转所有的卡片。</p>
<p>现在需要一个翻转的事件。在 <strong>OpenCardAction.swift</strong> 中添加代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReSwift</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlipCardAction</span>: <span class="title">Action</span></span>&#123;</div><div class="line">  <span class="keyword">let</span> cardIndexToFlip: <span class="type">Int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当卡片翻转的时候: FlipCardAction 使用 cardIndexToFlip 来更新 gameState 中的状态。</p>
<p>下一步修改 <code>gamereducer</code>  来支持这个 action。打开 <strong>GameReducer.swift</strong> 添加下面对应的case</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">case</span> <span class="keyword">let</span> flipCardAction <span class="keyword">as</span> <span class="type">FlipCardAction</span>:</div><div class="line">   state.memoryCards = flipCard(index: flipCardAction.cardIndexToFlip,</div><div class="line">                                memoryCards: state.memoryCards)</div><div class="line">state.gameFinishied = hasFinishedGame(cards: state.memoryCards)</div></pre></td></tr></table></figure>
<p>对 FlipCardAction 来说， flipCard 改变卡片的状态。hasFinishedGame 会在游戏结束的时候调用。两个方法都可以在 <strong>MemoryGameLogic.swift</strong> 中找到。</p>
<p>最后一个问题是在点击的时候，把翻转的 action 派发出去。</p>
<p>在 <strong>GameViewController.swift</strong> 中，找到 <code>UICollectionViewDelegate</code>  这个 extension。在 <code>collectionView(_:didSelectItemAt:)</code> 中添加:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="type">FlipCardAction</span>(cardIndexToFlip: indexPath.row))</div></pre></td></tr></table></figure>
<p>当卡片被选择的时候，关联的<code>indexPath.row</code> 就会跟着 <code>FlipcardAction</code> 被派发出去.</p>
<p>再运行一下，就会发现！</p>
<center><br><br><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-21-091810.jpg" width="200"><br><br></center>



<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>模版项目已经完整项目都在 <a href="https://github.com/CepheusSun/Translate/tree/master/demos/ReSwiftAndRedux">GitHub</a> </p>
<p>ReSwift 不仅仅是我们今天提到的内容。他还以很多:</p>
<ul>
<li><strong>Middleware</strong>: 中间件。swift目前还没有很好的办法来做切面。但是 ReSwift 解决了这个问题。可以使用ReSwift 的 [Middleware] 特性来解决这个问题。他能够让你轻松的切面(logging, 统计， 缓存)。</li>
<li><strong>Routing</strong>： 在这个 app 中已经实现了自己的 Routing， 还有个更通用的解决方案<a href="https://github.com/ReSwift/ReSwift-Router">ReSwift-Routing</a> 单这在社区还是一个还没有完全解决的问题。说不定解决它的人就是你！</li>
<li><strong>Testing</strong>: ReSwift 或许是最方便测试的框架了。 Reducer 包含了你需要测试的所有代码。他们都是纯的功能函数。这种函数在接受了同一个input 总是返回同一个值，他们不回依赖于程序当前的状态。</li>
<li><strong>Debugging</strong>： ReSwift 的所有状态都在一个结构体中定义，并且是单向数据流的，debug 会非常的简单，甚至你还可以用 <a href="https://github.com/ReSwift/ReSwift-Recorder">ReSwift-Recorder</a> 来记录下导致 crash 的状态</li>
<li><strong>Persistence</strong>: 因为所有的状态都在一个地方，拓展和坚持都是很容易的事情。缓存离线的数据也是一个比较麻烦的架构问题，但是 ReSwift 解决了这个问题。</li>
<li><strong>others</strong>： Redux 架构并不是一个库，它是一种编程范式，你也可以自己实现一套，还有 <a href="https://github.com/BendingSpoons/katana-swift">Katana</a> 或者 <a href="https://github.com/ReduxKit/ReduxKit">ReduxKit</a> 也可以做这件事</li>
</ul>
<p>如果你想学习更多关于 ReSwift 的东西，可以看 ReSwift 作者 <a href="https://news.realm.io/news/benji-encz-unidirectional-data-flow-swift/">Benjamin Encz</a> 的演讲视频</p>
<p><a href="http://christiantietze.de/posts/2016/01/reswift-level-indirection/">Christian Tietze’s blog</a> 的博客上有很多有趣的例子。</p>
<p><strong>这篇文章翻译自Ray wenderlich <a href="https://www.raywenderlich.com/155815/reswift-tutorial-memory-game-app">ReSwift Tutorial: Memory Game App</a>]</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 app 的发展， MVC 渐渐的满足不了业务的需求。大家都在探索各种各样的架构模式来适应这种情况，像是MVVM、VIPER、&lt;a href=&quot;https://eng.uber.com/new-rider-app/&quot;&gt;Riblets&lt;/a&gt; 等等。 他们都有各自的特点，但是都有同一个核心: 通过多向数据流将代码按照单一职责原则来划分代码。在多向数据流中，数据在各个模块中传递。&lt;/p&gt;
&lt;p&gt;多向数据流并不一定是你想要的，反而，单向数据流才是我们更喜欢的数据传递方式。在这个 ReSwift 的教程中，你会学到如何使用 ReSwift 来实现单向数据流，并完成一个状态驱动的游戏——&lt;strong&gt;MemoryTunes&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
      <category term="翻译" scheme="http://www.CepheusSun.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>面向 Extension 开发 🌞 Share Extension</title>
    <link href="http://www.CepheusSun.com/ShareExtension.html"/>
    <id>http://www.CepheusSun.com/ShareExtension.html</id>
    <published>2017-07-09T13:43:38.000Z</published>
    <updated>2017-07-09T13:53:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Share Extension 使用户在使用其他的app 的时候, 更加方便的将其内容分享出去，像是社会化分享还有上传服务器。比如说， 在一个 app 中有个分享按钮， 用户可以选择其中一个 Share Extension 来发表评论或者内容。</p>
<a id="more"></a>
<blockquote>
<p><strong>写在前面的话</strong></p>
<p>最好的 Share Extension 能够让用户能够很轻松的分享网页中的内容。如果你需要用一个扩展来让用户使用这些内容做一些其他的操作, 或者为用户提供他们所关心的内容的更新， Share Extension 可能就不是最好的解决方案了。</p>
</blockquote>
<h3 id="如何理解-Share-Extension"><a href="#如何理解-Share-Extension" class="headerlink" title="如何理解 Share Extension"></a>如何理解 Share Extension</h3><p> Share Extension 有以下几个特点：</p>
<ul>
<li>让用户更容易分享内容。</li>
<li>如果可以的话，能够让用户预览，编辑，标注，并且自定义内容。</li>
<li>在用户发送内容的时候，能够确保内容是合法的。</li>
</ul>
<p>用户能够通过系统提供的 UI 来获得他能够使用的 Share Extension。在 iOS 中， 用户点击分享按钮，然后从系统弹出来的分享区域中选择一个 Share Extension。</p>
<p>当用户选择了你的 Share Extension 之后，你需要展示一个包含了内容的视图，然后发表出去。你可以将你的视图机遇系统提供的 vc， 或者自定义一个。系统提供的那个提供了一些很常见的操作，比如说，预览，合法性判断，同步内容，以及视图的动画，还有设置发布。</p>
<h3 id="创建-Share-Extension"><a href="#创建-Share-Extension" class="headerlink" title="创建 Share Extension"></a>创建 Share Extension</h3><p>创建的过程类似于之前写的 <a href="http://cepheussun.com/TodayExtension.html">面向 Extension 开发 🌞 Today Extension</a></p>
<p>唯一不同的是 Today Extension 有唯一的一个 宿主 app 而 Share Extension 在使用的时候， 可能有很多的宿主 app 所以在运行的时候，需要选择一个宿主 app。 一般都是选择的 Safari 然后，随便打开一个网页，下面的分享按钮就可用了，点击之后，在分享列表里面就能够看到你的 app 咯。</p>
<blockquote>
<p>需要注意的是，这个时候看到的 Share Extension 的名称是你 Share Extension 的名称，这个是可以更app 名称不一样的。只要改 Share Extension 的 info.plist 中的 Bundle display name 为你想要的名称就可以了。</p>
</blockquote>
<h3 id="这篇文章要做什么？"><a href="#这篇文章要做什么？" class="headerlink" title="这篇文章要做什么？"></a>这篇文章要做什么？</h3><p>写到这里, 基本上已经完成了准备工作了。可能还有 创建 app groups 之类的工作，这块将在下面的内容中介绍。花了几天时间断断续续的研究 <code>Share Extension</code>，对比了系统中本来就存在的facebook twitter 以及国内的微博什么的。我将在本文中模仿着做一个类似的效果出来。</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-07-live.gif" alt=""></p>
<p>这是最终效果的 gif 图。这只是第一步。好了，我们开始吧。</p>
<h4 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">       <span class="keyword">super</span>.viewDidLoad()</div><div class="line">       placeholder = <span class="string">"分享到微博"</span>  <span class="comment">// 占位文字</span></div><div class="line">       charactersRemaining = <span class="number">140</span>  <span class="comment">// 左下角的文字 展示数字，可以用来倒数，还能输入几个字, 小于等于0的时候变成红色</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>如注释所见，这里设置了placeholder 已经右下角的数字。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 过滤分享的内容</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">isContentValid</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    charactersRemaining = <span class="number">140</span> - contentText.characters.<span class="built_in">count</span> <span class="keyword">as</span> <span class="type">NSNumber</span></div><div class="line">    <span class="keyword">return</span> contentText.characters.<span class="built_in">count</span> &gt; <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码用来验证用户输入的内容是否合法。这里我只是简单的设置了内容的长度不能超过140，并且不能小于2.</p>
<p>系统在<code>SLComposeServiceViewController</code>中提供了<code>open func didSelectPost()</code>、<code>open func didSelectCancel()</code> 两个方法分别是上面两个按钮的事件。</p>
<blockquote>
<p>需要注意的是，重写 cancel 的时候，需要调用 super</p>
</blockquote>
<p>接下来是设置位置，分组这些内容。这写也是在系统的api 中能找到对应的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">configurationItems</span><span class="params">()</span></span> -&gt; [<span class="type">Any</span>]! &#123;</div><div class="line">       <span class="comment">// 定位</span></div><div class="line">       <span class="keyword">let</span> item1 = <span class="type">SLComposeSheetConfigurationItem</span>()</div><div class="line">       item1?.title = <span class="string">"位置"</span></div><div class="line">       item1?.value = <span class="string">"无"</span></div><div class="line">       item1?.valuePending = <span class="literal">false</span></div><div class="line">       item1?.tapHandler = &#123;</div><div class="line">           item1?.valuePending = <span class="literal">true</span></div><div class="line">           <span class="comment">// 在这里做定位的操作</span></div><div class="line">           <span class="comment">// 模拟花了3s时间</span></div><div class="line">           delay(<span class="number">3</span>, task: &#123;</div><div class="line">               item1?.value = <span class="string">""</span></div><div class="line">               item1?.valuePending = <span class="literal">false</span></div><div class="line">               item1?.value = <span class="string">"四川省 成都市"</span></div><div class="line">           &#125;)</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       <span class="comment">// 跳转</span></div><div class="line">       <span class="keyword">let</span> item2 = <span class="type">SLComposeSheetConfigurationItem</span>()</div><div class="line">       item2?.title = <span class="string">"可见组"</span></div><div class="line">       item2?.value = <span class="string">""</span></div><div class="line">       </div><div class="line">       item2?.tapHandler = &#123;</div><div class="line">           <span class="keyword">let</span> list = <span class="type">ListController</span>()</div><div class="line">           list.callbackClosure = &#123;</div><div class="line">               item2?.value = $<span class="number">0</span></div><div class="line">           &#125;</div><div class="line">           <span class="keyword">self</span>.pushConfigurationViewController(list)</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       <span class="comment">// 测试预览</span></div><div class="line">       <span class="comment">/*</div><div class="line">       let item3 = SLComposeSheetConfigurationItem()</div><div class="line">       item3?.title = "预览"</div><div class="line">       item3?.tapHandler = &#123;</div><div class="line">           let pre = self.loadPreviewView()// 这个方法实际上是用来获取右边的图片的</div><div class="line">           pre?.frame = self.view.bounds</div><div class="line">           self.view.addSubview(pre!)</div><div class="line">       &#125;</div><div class="line">       */</span></div><div class="line">       <span class="keyword">return</span> [item1!, item2!]</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个方法返回了一个数组，就是对应的按钮等内容。每个按钮其实也很简单。只有 <code>title</code>，<code>value</code>， <code>tapHandler</code>， <code>valuePending</code> 四个属性。</p>
<ul>
<li>title: 左边的文字</li>
<li>value: 右边的文字</li>
<li>tapHandler： 处理这个 item 事件的 closure</li>
<li>valuePending： 左边转菊花的indicator，是一个 bool 类型的属性。</li>
</ul>
<p>在上面的代码里，我用 <code>self.pushConfigurationViewController(list)</code> 这行代码push 到了另外的界面，用来让用户选择他们要把消息分享到的具体分组。这个操作是在 Facebook 的 share extension 中看见的。在实际中，我们也可以这样做其他很多的事情。</p>
<blockquote>
<p>需要注意的是，推出来的 Controller 需要设置背景为clear，cell 也要设置背景为 clear 这是为了保证界面跟系统统一（模糊效果）。</p>
</blockquote>
<p>然后就是要把用户选择的内容分享出去了。</p>
<h4 id="通过-Share-Extension-分享内容"><a href="#通过-Share-Extension-分享内容" class="headerlink" title="通过 Share Extension 分享内容"></a>通过 Share Extension 分享内容</h4><p>要将内容分享出去，需要解决几个问题。</p>
<ul>
<li>用户信息</li>
<li>获取分享的内容</li>
</ul>
<p>因为 App Extension 和主 App 是两个不同的 Target， 这就需要我们在这个获取到主 app 中用户的登录信息。至少需要知道我们要把内容分享到哪个用户的数据流中吧。</p>
<p>这个其实也是很简单的事情。在 Today 中我们已经知道了 App Groups 这个东西。也知道了如何共享部分代码。</p>
<p>所以在 Share Extension 中</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchUserInfomation</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">    <span class="keyword">let</span> userdefault = <span class="type">UserDefaults</span>.<span class="keyword">init</span>(suiteName: <span class="string">"group.sunny.com"</span>)</div><div class="line">    <span class="keyword">let</span> info = userdefault?.value(forKey: <span class="string">"userInformation"</span>) <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">String</span>]</div><div class="line">    <span class="keyword">return</span> info?[<span class="string">"token"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在主app 中</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> userdefault = <span class="type">UserDefaults</span>(suiteName: <span class="string">"group.sunny.com"</span>)</div><div class="line">userdefault?.<span class="keyword">set</span>([<span class="string">"token"</span>: <span class="string">"this the user token"</span>], forKey: <span class="string">"userInformation"</span>)</div><div class="line">userdefault?.synchronize()</div></pre></td></tr></table></figure>
<p>就实现了数据之间的交换。到这儿，可能会想到另外一个问题。如果没有登录的话需要跳转到主 app 中进行登录操作。这里也没有什么问题通过 openurl 就可以。</p>
<ol>
<li>设置主app 的url type</li>
<li>跳转</li>
</ol>
<p>所以我在 <code>viewDidload</code> 方法中添加了以下代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> fetchUserInfomation() == <span class="literal">nil</span> &#123;</div><div class="line">            </div><div class="line">	<span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"还没有登录"</span>, message: <span class="literal">nil</span>, preferredStyle: .alert)</div><div class="line">	alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"取消"</span>, style: .cancel) &#123;<span class="number">_</span> <span class="keyword">in</span></div><div class="line">		<span class="keyword">self</span>.cancel()</div><div class="line">	&#125;)</div><div class="line">	alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"去登录"</span>, style: .<span class="keyword">default</span>) &#123;<span class="number">_</span> <span class="keyword">in</span></div><div class="line">	<span class="keyword">self</span>.extensionContext?.open(<span class="type">NSURL</span>(string: <span class="string">"sunny://action=login"</span>)! <span class="keyword">as</span> <span class="type">URL</span>, completionHandler: &#123; (success) <span class="keyword">in</span></div><div class="line">		<span class="keyword">self</span>.cancel()</div><div class="line">		<span class="built_in">print</span>(success)</div><div class="line">	&#125;)</div><div class="line">&#125;)</div><div class="line">	present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>判断登录状态，然后弹窗。取消或者去登录。如果选择去登录的话，就通过 openUrl 去打开主 app。</p>
<p>很完美吧！<strong>but it doesn’t work!!!</strong>， 我在 stackoverflow 上找到了些资料。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/24895093/openurl-doesnt-work-in-share-extension">openURL doesn’t work in Share extension</a></li>
<li><a href="https://stackoverflow.com/questions/24297273/openurl-not-work-in-action-extension">openURL not work in Action Extension</a></li>
</ul>
<blockquote>
<p>苹果爸爸只允许 Today Extension 通过 extensionContext 的 openUrl 打开主app</p>
</blockquote>
<p>但是这个需求总是需要实现的。其实还是有解决方法。</p>
<h5 id="方法一-在-Extension-中实现登录操作"><a href="#方法一-在-Extension-中实现登录操作" class="headerlink" title="方法一:  在 Extension 中实现登录操作"></a>方法一:  在 Extension 中实现登录操作</h5><p>这个确实没什么好说的。也是弹出一个 alert，然后输入用户名，密码，登录。完成所有操作。或者是其他什么方案，都可以。这个就不再详细描述了。Share Extension 来实现登录行为，然后 主 app 也能够共享等了状态。这仿佛也是解决了这种问题。</p>
<p>当然，强迫症笔者，还是想通过打开主 app 的方法来解决这个问题。</p>
<h5 id="方法二-另类的-openUrl"><a href="#方法二-另类的-openUrl" class="headerlink" title="方法二: 另类的 openUrl"></a>方法二: 另类的 openUrl</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// For skip compile error.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">openURL</span><span class="params">(<span class="number">_</span> url: URL)</span></span> &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">openContainerApp</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> responder: <span class="type">UIResponder</span>? = <span class="keyword">self</span> <span class="keyword">as</span> <span class="type">UIResponder</span></div><div class="line">    <span class="keyword">let</span> selector = #selector(openURL(<span class="number">_</span>:))</div><div class="line">    <span class="keyword">while</span> responder != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">if</span> responder!.responds(to: selector) &amp;&amp; responder != <span class="keyword">self</span> &#123;</div><div class="line">            responder!.perform(selector, with: <span class="type">URL</span>(string: <span class="string">"sunny://action=login"</span>)!)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        responder = responder?.next</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，上面的两个链接还有一些其他的方法，就不一一列举了。</p>
<p>解决了最开始的用户信息的问题。接下来就是要获取分享的内容这个问题了。在ShareExtension 中，相信已经看见了。需要两个东西，第一个是用户关于这个内容的评论，以及这个内容本身（url、照片等）。关于用户对内容的评论这点其实很简单。</p>
<h5 id="用户评论"><a href="#用户评论" class="headerlink" title="用户评论"></a>用户评论</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Convenience. This returns the current text from the textView.</span></div><div class="line">open <span class="keyword">var</span> contentText: <span class="type">String</span>! &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>系统提供的这个 api 就能够解决这个问题。</p>
<h5 id="附件内容"><a href="#附件内容" class="headerlink" title="附件内容"></a>附件内容</h5><p>暂且叫做附件内容吧！我也不知道应该怎么叫。这个东西，我们还是看看 <code>extensionContext</code> 这个东西吧！</p>
<p><code>NSExtensionContext</code> 这个类一共暴露了四个api出来。我们看第一个</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The list of input NSExtensionItems associated with the context. If the context has no input items, this array will be empty.</span></div><div class="line">open <span class="keyword">var</span> inputItems: [<span class="type">Any</span>] &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>看样子就是这个了。</p>
<blockquote>
<p>看注释内容，突然感觉，apple 的api 也有设计的不是很好的地方，既然注释都明确说了 NSExtensionItems 数组应该不是 Any 的吧😂</p>
</blockquote>
<p>既然这样, 我们再看看 <code>NSExtensionItem</code> 这个类吧！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// (optional) title for the item</span></div><div class="line"><span class="meta">@NSCopying</span> open <span class="keyword">var</span> attributedTitle: <span class="type">NSAttributedString</span>?</div><div class="line"><span class="comment">// (optional) content text</span></div><div class="line"><span class="meta">@NSCopying</span> open <span class="keyword">var</span> attributedContentText: <span class="type">NSAttributedString</span>?</div><div class="line"><span class="comment">// (optional) Contains images, videos, URLs, etc. This is not meant to be an array of alternate data formats/types, but instead a collection to include in a social media post for example. These items are always typed NSItemProvider.</span></div><div class="line">open <span class="keyword">var</span> attachments: [<span class="type">Any</span>]?</div><div class="line"><span class="comment">// (optional) dictionary of key-value data. The key/value pairs accepted by the service are expected to be specified in the extension's Info.plist. The values of NSExtensionItem's properties will be reflected into the dictionary.</span></div><div class="line">open <span class="keyword">var</span> userInfo: [<span class="type">AnyHashable</span> : <span class="type">Any</span>]?</div></pre></td></tr></table></figure>
<p>注释太复杂了，整理成一个表格就是这样的:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Properties</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">attributedTitle</td>
<td style="text-align:center">标题 optional</td>
</tr>
<tr>
<td style="text-align:center">attributedContentText</td>
<td style="text-align:center">内容 optional</td>
</tr>
<tr>
<td style="text-align:center">attachments</td>
<td style="text-align:center">所有的附件<code>NSItemProvider</code>组成一个数组 optional</td>
</tr>
<tr>
<td style="text-align:center">userInfo</td>
<td style="text-align:center">一个key－value结构的数据。NSExtensionItem中的属性都会在这个属性中一一映射。注释中讲到的在 info.plist 中要设置的部分会在后面提到</td>
</tr>
</tbody>
</table>
<p> 下面的表格就是 <code>userInfo</code> 中的 key :</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NSExtensionItemAttributedTitleKey</td>
<td style="text-align:center">标题 的键名</td>
</tr>
<tr>
<td style="text-align:center">NSExtensionItemAttributedContentTextKey</td>
<td style="text-align:center">内容 的键名</td>
</tr>
<tr>
<td style="text-align:center">NSExtensionItemAttachmentsKey</td>
<td style="text-align:center">附件 的键名</td>
</tr>
</tbody>
</table>
<p>上面又提到了 <code>NSItemProvider</code> 这个东西。这相必须就是我们需要的附件了吧！</p>
<table>
<thead>
<tr>
<th>Api</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>initWithItem:typeIdentifier：</td>
<td>初始化方法，item为附件的数据，typeIdentifier是附件对应的类型标识,对应UTI的描述。</td>
</tr>
<tr>
<td>initWithContentsOfURL:</td>
<td>根据制定的文件路径来初始化。</td>
</tr>
<tr>
<td>registerItemForTypeIdentifier:loadHandler:</td>
<td>为一种资源类型自定义加载过程。这个方法主要针对自定义资源使用，例如自己定义的类或者文件格式等。当调用loadItemForTypeIdentifier:options:completionHandler:方法时就会触发定义的加载过程。</td>
</tr>
<tr>
<td>hasItemConformingToTypeIdentifier:</td>
<td>用于判断是否有typeIdentifier(UTI)所指定的资源存在。存在则返回YES，否则返回NO。该方法结合loadItemForTypeIdentifier:options:completionHandler:使用。</td>
</tr>
<tr>
<td>loadItemForTypeIdentifier:options:completionHandler:</td>
<td>加载typeIdentifier指定的资源。加载是一个异步过程，加载完成后会触发completionHandler。</td>
</tr>
<tr>
<td>loadPreviewImageWithOptions:completionHandler:</td>
<td>加载资源的预览图片。</td>
</tr>
</tbody>
</table>
<p>这时候看看整体的结构：(<a href="http://www.jianshu.com/p/863ce6729455">这个图是在看到的</a>)</p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-09-5D4D49E7-5087-4D01-B78A-D3BCF979E979.png" alt=""></p>
<p>到这里，应该已经知道了应该怎么做了吧！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 点击发表的事件</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didSelectPost</span><span class="params">()</span></span> &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.extensionContext?.inputItems.forEach(&#123; (item) <span class="keyword">in</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"//////////////////////////"</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> ext = item <span class="keyword">as</span>! <span class="type">NSExtensionItem</span></div><div class="line">        ext.attachments?.forEach(&#123;</div><div class="line">            <span class="keyword">let</span> atta = $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">NSItemProvider</span></div><div class="line">            <span class="built_in">print</span>(atta)</div><div class="line">            <span class="comment">// 分享的是网页</span></div><div class="line">            <span class="keyword">if</span> atta.hasItemConformingToTypeIdentifier(<span class="string">"public.url"</span>) &#123;</div><div class="line">                atta.loadItem(forTypeIdentifier: <span class="string">"public.url"</span>) &#123; (item, error) <span class="keyword">in</span></div><div class="line">                    <span class="built_in">print</span>(<span class="string">"//////////////////////////"</span>)</div><div class="line">                    <span class="built_in">print</span>(item!)</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"//////////////////////////"</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 分享的是图片</span></div><div class="line">            <span class="keyword">if</span> atta.hasItemConformingToTypeIdentifier(<span class="string">"public.jpeg"</span>) &#123;</div><div class="line">                atta.loadItem(forTypeIdentifier: <span class="string">"public.jpeg"</span>) &#123; (item, error) <span class="keyword">in</span></div><div class="line">                    <span class="built_in">print</span>(<span class="string">"//////////////////////////"</span>)</div><div class="line">                    <span class="built_in">print</span>(item!)</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"//////////////////////////"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">self</span>.extensionContext!.completeRequest(returningItems: [], completionHandler: <span class="literal">nil</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中分别是分享网页和图片两个东西。这一步解决了找到分享的内容的代码。</p>
<p><strong>具体分享的行为可以有两个办法来解决</strong></p>
<ul>
<li>将需要分享的内容功过 apps group 保存，然后在打开主 app 的时候，在主 app 中取出然后发送给sever。</li>
<li>直接在 Share Extension 中分享。</li>
</ul>
<p>这个过程就不再叙述了。</p>
<h4 id="info-plist"><a href="#info-plist" class="headerlink" title="info.plist"></a>info.plist</h4><p>既然说到了 info.plist 中的设置，就再看看这部分是说的什么吧！都是一些很固定的内容，我随便挑两个说说吧！</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSExtensionActivationSupportsAttachmentsWithMaxCount</td>
<td>附件最大个数</td>
</tr>
<tr>
<td>NSExtensionActivationSupportsAttachmentsWithMinCount</td>
<td>附件最小个数</td>
</tr>
<tr>
<td>NSExtensionActivationSupportsFileWithMaxCount</td>
<td>附件种类限制</td>
</tr>
<tr>
<td>NSExtensionActivationSupportsMovieWithMaxCount</td>
<td>视频个数限制</td>
</tr>
<tr>
<td>NSExtensionActivationSupportsImageWithMaxCount</td>
<td>图片个数限制</td>
</tr>
<tr>
<td>NSExtensionActivationSupportsText</td>
<td>是否支持文本类型</td>
</tr>
<tr>
<td>NSExtensionActivationSupportsWebURLWithMaxCount</td>
<td>web 链接最多限制</td>
</tr>
<tr>
<td>NSExtensionActivationSupportsWebPageWithMaxCount</td>
<td>web 页面最多限制</td>
</tr>
</tbody>
</table>
<p>如果要设置你的 extension 只支持图片，url 什么的。只需要把个数限制写成 0！</p>
<p>但是设置的时候需要注意是将NSExtensionActivationRule 改成 Dictionary 类型并添加：</p>
<ul>
<li>NSExtensionActivationSupportsAttachmentsWithMaxCount</li>
<li>NSExtensionActivationSupportsAttachmentsWithMinCount</li>
<li>NSExtensionActivationSupportsImageWithMaxCount</li>
<li>NSExtensionActivationSupportsMovieWithMaxCount</li>
<li>NSExtensionActivationSupportsWebPageWithMaxCount</li>
<li>NSExtensionActivationSupportsWebURLWithMaxCount</li>
</ul>
<p>这就基本上完成了，我们要在 系统或者 外部 app 中将内容分享到我们自己的 app 中。这好像还是有很大的限制。毕竟如果我们的产品不是像微博qq这样的社交app 的话，这个东西就没什么作用了。</p>
<p><strong>另外注意这个警告</strong></p>
<p><img src="http://ocg4av0wv.bkt.clouddn.com/2017-07-09-133823.jpg" alt=""></p>
<h3 id="在自己的app-中调起-Share-Extension"><a href="#在自己的app-中调起-Share-Extension" class="headerlink" title="在自己的app 中调起 Share Extension"></a>在自己的app 中调起 Share Extension</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> activity = <span class="type">UIActivityViewController</span>(activityItems: [<span class="string">"百度"</span>, <span class="type">URL</span>(string: <span class="string">"http://www.baidu.com"</span>)!], applicationActivities: <span class="literal">nil</span>)</div><div class="line"><span class="comment">// 不分享到 airDrop 和 粘贴板</span></div><div class="line">activity.excludedActivityTypes = [.airDrop, .copyToPasteboard]</div><div class="line">present(activity, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>当然还有 <code>UIActivityViewControllerCompletionHandler</code> 这个东西，来回调分享的结果。</p>
<p><strong>另外一种方法</strong>可以直接调起某个系统的分享。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断是否支持 微博</span></div><div class="line">     </div><div class="line">     <span class="keyword">if</span> !<span class="type">SLComposeViewController</span>.isAvailable(forServiceType: <span class="type">SLServiceTypeSinaWeibo</span>) &#123;</div><div class="line">         <span class="comment">// 应该是没有登录的原因, 所以一直不会返回</span></div><div class="line">         <span class="built_in">print</span>(<span class="string">"不可用"</span>)</div><div class="line">         <span class="keyword">return</span></div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="keyword">let</span> composeVC = <span class="type">SLComposeViewController</span>(forServiceType: <span class="type">SLServiceTypeSinaWeibo</span>)</div><div class="line">     <span class="comment">//        // 添加要分享的图片</span></div><div class="line">     <span class="comment">//        composeVC?.add(UIImage(named: "Nameless"))</span></div><div class="line">     <span class="comment">//        // 添加要分享的文字</span></div><div class="line">     <span class="comment">//        composeVC?.setInitialText("分享到XXX")</span></div><div class="line">     <span class="comment">//        // 添加要分享的url</span></div><div class="line">     <span class="comment">//        composeVC?.add(URL(string: "http://www.baidu.com"))</span></div><div class="line">     <span class="comment">//        // 弹出分享控制器</span></div><div class="line">     <span class="keyword">self</span>.present(composeVC!, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">     <span class="comment">//        // 监听用户点击事件</span></div><div class="line">     composeVC?.completionHandler = &#123;</div><div class="line">         <span class="keyword">if</span> $<span class="number">0</span> == .done &#123;</div><div class="line">             <span class="type">NSLog</span>(<span class="string">"点击了发送"</span>);</div><div class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> $<span class="number">0</span> == .cancelled &#123;</div><div class="line">             <span class="type">NSLog</span>(<span class="string">"点击了取消"</span>);</div><div class="line">         &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>这种方式有一个缺陷，就是，这样的分享只能对系统的分享，微信什么的就不能这么做了。</p>
<h3 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h3><p>Share Extension 写到这里就差不多了。初步的入门步骤也已经完成了。最后，我看了一下，微信的 Share Extension 做的事情，感觉用他还能做很多的事情。这个也需要在开发中根据实际需求去拓展了，另外还有自定义 UI 等，也是很简单的事情。只是用自己 UIViewController 就好了。这个就不再详细的说了。到此，我能想到的功能，就基本上完成了。如果有更多需求也可以跟我讨论。</p>
<p><a href="https://github.com/CepheusSun/ShareExtension"><strong>demo地址</strong></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Share Extension 使用户在使用其他的app 的时候, 更加方便的将其内容分享出去，像是社会化分享还有上传服务器。比如说， 在一个 app 中有个分享按钮， 用户可以选择其中一个 Share Extension 来发表评论或者内容。&lt;/p&gt;
    
    </summary>
    
      <category term="App Extension" scheme="http://www.CepheusSun.com/categories/App-Extension/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="App Extension" scheme="http://www.CepheusSun.com/tags/App-Extension/"/>
    
  </entry>
  
  <entry>
    <title>面向 Extension 开发 🌞 Today Extension</title>
    <link href="http://www.CepheusSun.com/TodayExtension.html"/>
    <id>http://www.CepheusSun.com/TodayExtension.html</id>
    <published>2017-06-30T10:41:38.000Z</published>
    <updated>2017-07-09T13:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>app extension 让我们在用户正在使用其他 app 的时候, 拓展我们 app 的功能。</p>
<p>Today Extension 也叫做 widget。 它能够让一些重要的消息更快速的到达你的用户。比如说, 用户可以通过它查看天气，或者股票价格, 查看日程表等等。苹果在官方文档中说到， 一个 widget 应该有以下的特点。</p>
<ul>
<li>确保内容是最新的</li>
<li>响应的用户事件</li>
<li>性能好(在iOS上占用大量内存，系统可能会kill掉这个widget)</li>
</ul>
<a id="more"></a>
<h3 id="创建-Today-Extension"><a href="#创建-Today-Extension" class="headerlink" title="创建 Today Extension"></a>创建 Today Extension</h3><p>Xcode -&gt; File -&gt; New -&gt; Target -&gt; TodayExtension</p>
<p>跟创建一个新的项目一样, 设置创建好之后, 项目中会多一个 Target, 修改Scheme 为你刚刚创建的 Extension 再运行, 就能在 通知中心的 Today 里面看到你刚刚创建的 widget 了, 上面写着“Hello world”</p>
<p>另外 Xcode 给你创建了默认的模版文件。</p>
<ul>
<li>TodayViewController.swift(如果是 OC 对应会是 <code>.h</code> 和 <code>.m</code> 文件)</li>
<li>MainInterface.storyboard</li>
<li>Info.plist</li>
</ul>
<p><strong>注意:</strong> 默认是使用这个 storyboard 作为这个 widget 的入口。如果不需要使用storyboard 可以删除掉这个storyboard并且将Info.plist 中的</p>
<ul>
<li><code>NSExtensionMainStoryboard</code> 改成 <code>NSExtensionPrincipalClass</code></li>
<li><code>MainInterface</code> 改成 <code>TodayViewController</code></li>
</ul>
<h3 id="设置界面"><a href="#设置界面" class="headerlink" title="设置界面"></a>设置界面</h3><p>完成了上面的步骤之后, 不论你是选择用 stroyboard 作为你 widget 的入口, 还是选择用代码来做这件事情。都是一样的。</p>
<blockquote>
<p>由于不知道什么原因, 我在网上看到的文章都是使用代码来做的这件事情。所以在这篇文章以及后面的示例代码中都将使用 Xcode 默认的 storyboard 来做这个 widget 的布局。</p>
</blockquote>
<h3 id="我将解决的问题"><a href="#我将解决的问题" class="headerlink" title="我将解决的问题"></a>我将解决的问题</h3><ul>
<li>在 widget 中打开主 app 并传递参数</li>
<li>widget 和 主 app 共享数据</li>
<li>widget 和 主 app 共用资源</li>
<li>widget 的打开和折叠</li>
</ul>
<h3 id="我遇到的坑"><a href="#我遇到的坑" class="headerlink" title="我遇到的坑"></a>我遇到的坑</h3><p>也没什么坑, 毕竟 Today Extension 并不是什么很难的东西。</p>
<ul>
<li>测试的时候, 由于 widget 和 主app 是两个不同的 target, 所以在传递参数的时候, 在 appdelegate 中打印对应的值没有效果。最开始我还以为是因为设置的 scheme 是 widget 所以在 主 app 中的修改是无效的。但是实际是并不是这样。将参数以 alert 的形式表现出来, 这时候能够发现, 其实主 app 是跑起来了的。</li>
</ul>
<h3 id="先说说我做的准备工作吧"><a href="#先说说我做的准备工作吧" class="headerlink" title="先说说我做的准备工作吧"></a>先说说我做的准备工作吧</h3><p>为了不扯那么多没用的东西。先说说我做了那些跟今天主题没什么关系的事情。</p>
<h4 id="写主app"><a href="#写主app" class="headerlink" title="写主app"></a>写主app</h4><p>在主 app 中我写了一个 UITableView, 并使用 Userdefault 将我要持久化的数据保存下来。然后对应给 Todo list 做了，添加，和删除的功能。</p>
<h4 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h4><p>在 widget 中我也下了同样的一个 UITableView 只有查看的功能。</p>
<h4 id="要做的事情"><a href="#要做的事情" class="headerlink" title="要做的事情"></a>要做的事情</h4><h5 id="widget-和-主-app-共用资源"><a href="#widget-和-主-app-共用资源" class="headerlink" title="widget 和 主 app 共用资源"></a>widget 和 主 app 共用资源</h5><p>widget 和 主app 共享代码和资源。作为一个工程师, 我们在任何事情的时候都要想到高类聚低耦合着句不变的真理。所以我们还是要尽可能的让 widget 和 主 app 共享代码。</p>
<p>主要有两个方案:</p>
<ul>
<li>framework</li>
<li>直接共享</li>
</ul>
<p>framework 的话，就拿 cocoapods 来说吧， 由于 widget 是一个新的target, 所以只需要在 podfile 中对应添加代码就能够在 widget 中使用。</p>
<p>另外一个是 直接共享, 这个就很简单了。我在示例中让主app 和 widget 共享了一张图片，一个 TodoCell 类(包括xib 文件)。我做的唯一的一件事情就是在 Xcode 中选中这个文件，然后在 Xcode右边的 TargetMenberShip 中勾选对应的 target.</p>
<h5 id="widget-和-主-app-共享数据"><a href="#widget-和-主-app-共享数据" class="headerlink" title="widget 和 主 app 共享数据"></a>widget 和 主 app 共享数据</h5><p>严格来说 widget 和 app 是不同的两个 app 了, 他们之间要共享数据的话只能使用 <strong>App Groups</strong> 了。</p>
<p>首先在主 app</p>
<p>target -&gt; capabilities -&gt; app groups</p>
<p>打开 app groups 功能, 点击 <code>+</code> , 设置 id 。如果重复了就改一个。</p>
<p>widget app</p>
<p>target -&gt; capabilities -&gt; app groups</p>
<p>这时候的 group 列表就能够看到对应的 group 了。勾选即可。</p>
<p>这时候已经完成了widget 和 主app共享数据的前提条件。</p>
<p>接下来还需要做的事情, 就是将我们准备工作里面Userdefault相关代码进行调整。</p>
<p>将 <code>UserDefaults.standard</code> 改成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UserDefaults(suiteName: &quot;your group id&quot;)</div></pre></td></tr></table></figure>
<p>这样就可以在 widget 中 使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> userdefault = <span class="type">UserDefaults</span>(suiteName: <span class="string">"group.com.sunny.group"</span>)</div></pre></td></tr></table></figure>
<p>获得在主 app 中持久化的数据了。关于 app groups 其他的用法，可以继续深入研究。</p>
<h5 id="widget-的折叠和展开"><a href="#widget-的折叠和展开" class="headerlink" title="widget 的折叠和展开"></a>widget 的折叠和展开</h5><p>苹果的官方文档里面明确的说了，widget 的界面是不能滑动的。毕竟 widget 和通知中心的滑动不能冲突啊。</p>
<p>所以有时候我们需要将 widget 折叠起来，毕竟太长的 widget 实在是令人讨厌啊。</p>
<p>主要还是说说iOS10 上怎么做的吧，毕竟没有iOS10 以下的设备。</p>
<p>在 TodayViewController 的 didLoad 中添加</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">        <span class="comment">// iOS10 添加折叠按钮</span></div><div class="line">        <span class="keyword">if</span> #available(iOSApplicationExtension <span class="number">10.0</span>, *) &#123;</div><div class="line">            extensionContext?.widgetLargestAvailableDisplayMode = .expanded</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">// iOS8 、iOS9 上需要自己添加折叠按钮</span></div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>然后实现 <code>NCWidgetProviding</code> 协议中的方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">widgetActiveDisplayModeDidChange</span><span class="params">(<span class="number">_</span> activeDisplayMode: NCWidgetDisplayMode, withMaximumSize maxSize: CGSize)</span></span> &#123;</div><div class="line"><span class="comment">// 由于 iOS8 、iOS9 上没有这个代理。需要对自己添加的按钮设置 target-action 然后进行修改</span></div><div class="line">        <span class="keyword">switch</span> activeDisplayMode &#123;</div><div class="line">        <span class="keyword">case</span> .compact:</div><div class="line">            preferredContentSize = maxSize</div><div class="line">        <span class="keyword">case</span> .expanded:</div><div class="line">            preferredContentSize = <span class="type">CGSize</span>(width: <span class="number">0.0</span>, height: <span class="number">60</span> * <span class="type">CGFloat</span>(dataSource.<span class="built_in">count</span>))</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在 iOS8 和 iOS9 中, 由于系统没有这个功能。我们只能自己写一个按钮然后再来做这些事情了。</p>
<h5 id="widget-打开-主app"><a href="#widget-打开-主app" class="headerlink" title="widget 打开 主app"></a>widget 打开 主app</h5><p>widget 打开主 app 还是老思路，openurl 就可以了，然后在url 中添加对应需要的参数。</p>
<p><strong>准备工作</strong> </p>
<p>主app -&gt; target -&gt; info -&gt; UrlTypes </p>
<p>添加一个 URlType 然后设置 URL Scheme 为你自定义的字符串。 比如 “sunny”。</p>
<p>在 widget 中需要跳转的地方写这样的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.extensionContext?.open(<span class="type">NSURL</span>(string: <span class="string">"sunny://action=<span class="subst">\(dataSource[indexPath.row])</span>"</span>)</div></pre></td></tr></table></figure>
<p>参数传递也就是按照上文, 在url中拼接了。上文有提到, widget 和 app 可以共享数据。这也可能是一种传递参数的方式。</p>
<p>这个时候打开主要 app 就是直接进入主要界面了。如果我们需要做一些其他的事情应该怎么做呢？</p>
<p>想想以前做微信或者支付宝支付的时候， 都要在 appdelegate 中写一些代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:])</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">prefix</span> = <span class="string">"sunny://"</span><span class="comment">// 判断是否是可靠的地方传递过来的</span></div><div class="line">    <span class="keyword">if</span> url.absoluteString.hasPrefix(<span class="keyword">prefix</span>) &#123;</div><div class="line">    <span class="comment">// 参数过来了！ 做对应的事情</span></div><div class="line">        <span class="keyword">let</span> a = <span class="type">UIAlertController</span>(title: url.absoluteString, message: <span class="literal">nil</span>, preferredStyle: .alert)</div><div class="line">        a.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"取消"</span>, style: .cancel, handler: <span class="literal">nil</span>))</div><div class="line">        <span class="keyword">self</span>.window?.rootViewController?.present(a, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="others"><a href="#others" class="headerlink" title="others"></a>others</h4><h5 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h5><p>widget的默认高度是有限制的。</p>
<p>compact 下:</p>
<ul>
<li>max = 110</li>
<li>mim = 110</li>
</ul>
<p>expanded 下:</p>
<ul>
<li>min = 110</li>
<li>max = 根据不同的机型二不同。</li>
</ul>
<p>无论怎么设置, 都不回超出这个范围</p>
<h5 id="widgetPerformUpdate"><a href="#widgetPerformUpdate" class="headerlink" title="widgetPerformUpdate"></a>widgetPerformUpdate</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func widgetPerformUpdate(completionHandler: (@escaping (NCUpdateResult) -&gt; Void)) &#123;</div><div class="line">    // Perform any setup necessary in order to update the view.</div><div class="line">    </div><div class="line">    // If an error is encountered, use NCUpdateResult.Failed</div><div class="line">    // If there&apos;s no update required, use NCUpdateResult.NoData</div><div class="line">    // If there&apos;s an update, use NCUpdateResult.NewData</div><div class="line">    </div><div class="line">    completionHandler(NCUpdateResult.newData)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法用来选择 widget 再出现的时候会不会重新刷新。</p>
<h5 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h5><p><del>在 <code>NSExtensionContext</code> 中看到的几个通知貌似不是给 TodayExtension 用的。</del></p>
<p><code>NSExtensionContext</code> 中能看到几个通知他们都是监听 host app 的状态的。所以对于widget 来说， host app 就是 Today 这个东西啦。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>抛砖引玉，本文用Today Extension做了一个很简单的功能。 当然, 我们能用他做的事情可不止这些。这就需要我们发动我们的聪明才智了。</p>
<p><a href="https://github.com/CepheusSun/TodayExtension">示例代码下载链接</a>由于使用swift写的, 由于众所周知的原因, 你发现编译不过了。可以联系我, 我将做适配。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;app extension 让我们在用户正在使用其他 app 的时候, 拓展我们 app 的功能。&lt;/p&gt;
&lt;p&gt;Today Extension 也叫做 widget。 它能够让一些重要的消息更快速的到达你的用户。比如说, 用户可以通过它查看天气，或者股票价格, 查看日程表等等。苹果在官方文档中说到， 一个 widget 应该有以下的特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保内容是最新的&lt;/li&gt;
&lt;li&gt;响应的用户事件&lt;/li&gt;
&lt;li&gt;性能好(在iOS上占用大量内存，系统可能会kill掉这个widget)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="App Extension" scheme="http://www.CepheusSun.com/categories/App-Extension/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="App Extension" scheme="http://www.CepheusSun.com/tags/App-Extension/"/>
    
  </entry>
  
  <entry>
    <title>Handing non-optional optionals in Swift</title>
    <link href="http://www.CepheusSun.com/Handing%20non-optional%20optionals%20in%20Swift.html"/>
    <id>http://www.CepheusSun.com/Handing non-optional optionals in Swift.html</id>
    <published>2017-06-09T02:05:23.000Z</published>
    <updated>2017-06-09T02:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>optional</strong>, 可以说是 Swift 中最为重要的特性, 也是它跟 <code>Objective-C</code> 不同的关键特征。在编码的时候强制处理那些可能为空的值, 可以让程序更具有可预测性, 减少错误发生的机会。</p>
<p>然而在开发中我们经常会遇到一些变量, 明明是 <code>optional</code> 的, 但在逻辑又一定是非空的。比如说 <code>controller</code> 中的 <code>view</code></p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewModel</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> tableView: <span class="type">UITableView</span>?</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        tableView = <span class="type">UITableView</span>.<span class="keyword">init</span>(frame: view.bounds)</div><div class="line">        view.addSubview(tableView!)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewModelDidUpdate</span><span class="params">(<span class="number">_</span> viewModel: ViewModel)</span></span> &#123;</div><div class="line">        tableView?.reloadData()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如何处理这种情况在 <code>Swift</code> 程序员之间的争议, 就使用 <code>tab</code> 还是 <code>space</code>来缩进一样。</p>
<blockquote>
<p>既然是可选类型, 我们就应该正确的使用它。 使用<code>if let</code> 或者 <code>guard</code></p>
</blockquote>
<p>也有人持有相反的态度: </p>
<blockquote>
<p>既然都知道这个变量非空, 那就强制解包。就算崩溃也不能让程序进入不可控的状态。</p>
</blockquote>
<p>上面的讨论基本上都是围绕着<strong>是否有必要进行防御性编程</strong>展开的。应该让程序从未定义的状态中恢复, 还是应该让程序直接崩溃。</p>
<p>如果非要回答这个问题, 我可能会选择后者。未定义的状态会导致很难追踪的 bug, 可能会执行不必要的代码。而且防御性的代码往往也很难维护。</p>
<p>但是我觉得, 研究一些避免出现这种情况的技巧更实在一些。</p>
<h3 id="Is-it-really-optional"><a href="#Is-it-really-optional" class="headerlink" title="Is it really optional?"></a>Is it really optional?</h3><p>变量和属性是不是可选取决于你代码的逻辑。如果在设计程序的时候, 根本就没有想过这个变量会是 <code>nil</code>。或者说在设计之初, 这个变量就不会出现为空的情况。这个变量就不应该是 <code>optional</code> </p>
<p>即使在和一些系统 API 交互的时候, 可选类型基本上都是无法避免的。但是也有一些办法让我们尽可能的避免使用 <code>optional</code> 类型。</p>
<h3 id="Being-lazy-is-better-than-being-non-optionally-optional"><a href="#Being-lazy-is-better-than-being-non-optionally-optional" class="headerlink" title="Being lazy is better than being non-optionally optional"></a>Being lazy is better than being non-optionally optional</h3><p>对于一个对象来说, 如果它的属性会在这个对象初始化之后赋值。比如说 <code>UIController</code> 上面的 <code>View</code> 应该在 <code>viewDidLoad()</code> 中初始化。就可以使用 <code>lazy</code> 属性。一个懒加载属性是不可空的, 即使他在这个对象的初始化方法中没有被赋值。因为在第一次访问的时候, 它就会被初始化出来。</p>
<p>我们来更新一下刚才的代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewModel</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> tableView = <span class="type">UITableView</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        tableView = <span class="type">UITableView</span>.<span class="keyword">init</span>(frame: view.bounds)</div><div class="line">        view.addSubview(tableView)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewModelDidUpdate</span><span class="params">(<span class="number">_</span> viewModel: ViewModel)</span></span> &#123;</div><div class="line">        tableView.reloadData()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没有可空类型了。🎉</p>
<h3 id="Proper-dependency-management-is-better-than-non-optional-optionals"><a href="#Proper-dependency-management-is-better-than-non-optional-optionals" class="headerlink" title="Proper dependency management is better than non-optional optionals"></a>Proper dependency management is better than non-optional optionals</h3><p>为了打破循环依赖我们也经常会使用可选类型。比如：在A、B两个类互相依赖的时候: </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>(text: <span class="type">String</span>) &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> commentManager: <span class="type">CommentManager</span>?</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userDidpostComment</span><span class="params">(<span class="number">_</span> comment: Comment)</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">logOutCurrentUser</span><span class="params">()</span></span> &#123;</div><div class="line">        commentManager?.clearCache()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> userManager: <span class="type">UserManager</span>?</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">composer</span><span class="params">(<span class="number">_</span> composer: Comment)</span></span> &#123;</div><div class="line">        userManager?.userDidpostComment(composer)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clearCache</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上面的代码我们可以发现一个很明显的循环引用 <code>UserManager</code> - <code>CommentManager</code> 任何一个都没有持有另外一个, 但是它们也依赖另外一个来完成自己的业务逻辑。😅</p>
<p>解决这样的问题, 我们可以让 <code>CommentComposer</code> 来做为中间人。 他来通知 <code>UserManger</code> 还有 <code>CommentManager</code> 一条评论消息产生了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentComposer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">let</span> commentManager: <span class="type">CommentManager</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userManager: <span class="type">UserManager</span></div><div class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> textView = <span class="type">UITextView</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(commentManager: <span class="type">CommentManager</span>,</div><div class="line">         userManager: <span class="type">UserManager</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.commentManager = commentManager</div><div class="line">        <span class="keyword">self</span>.userManager = userManager</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">postComment</span><span class="params">()</span></span>  &#123;</div><div class="line">        <span class="keyword">let</span> comment = <span class="type">Comment</span>(text: textView.text)</div><div class="line">        commentManager.composer(comment)</div><div class="line">        userManager.userDidpostComment(comment)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话 <code>UserManager</code> 就可以强引用 <code>CommentManager</code> 了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">let</span> commentManager: <span class="type">CommentManager</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(commentManager: <span class="type">CommentManager</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.commentManager = commentManager</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userDidpostComment</span><span class="params">(<span class="number">_</span> comment: Comment)</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">logOutCurrentUser</span><span class="params">()</span></span> &#123;</div><div class="line">        commentManager.clearCache()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>optional</code> 也消失了🎉</p>
<h3 id="Crashing-gracefully"><a href="#Crashing-gracefully" class="headerlink" title="Crashing gracefully"></a>Crashing gracefully</h3><p>上面的例子中，我们看到了两个通过调整我们的代码, 来控制代码中的不确定性。但是在有些情况下这么做是不可能的。我们来假设一下, 你正在加载一个包含了你程序的配置信息的 JSON 文件。这就天然的存在一些可能会出错的情况。此时需要做的就是尽可能的错误处理。</p>
<p>拿到了错误的配置文件, 如果继续往下执行的话, 程序进入我们没有定义的状态中。这种情况下, 最好的办法是让程序崩溃, 然后 QA 中, 通过日志, 将这个问题解决掉。</p>
<p>那么我们应该怎么来让程序崩溃呢。最简单的办法就是使用 <code>!</code> 操作符。当这个变量为空的时候强制解包, 就会导致程序崩溃。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> configuration = loadConfiguration()!</div></pre></td></tr></table></figure>
<p>虽然这种方法很简单, 但是它也有很大的缺点。如果这个代码 crash。 我们得到的日志是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal error: unexpectedly found nil while unwrapping an Optional value</div></pre></td></tr></table></figure>
<p>没有错误原因, 也没有错误发生的地点。这样的错误信息基本上没有什么能够让我们迅速的解决这个 bug 的信息。</p>
<p>更好的方法是在 <code>guard</code> 表达式中使用 <code>preconditionFailure()</code> 函数让程序发生崩溃, 抛出自定义的错误信息。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> configuration = loadConfiguration() <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">preconditionFailure</span>(<span class="string">"Configuration couldn't be loaded + verifu that Config.JSON is valid"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话, 在程序崩溃的时候我们就能得到有用的信息了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal error: <span class="type">Configuration</span> couldn’t be loaded. <span class="type">Verify</span> that <span class="type">Config</span>.<span class="type">JSON</span> <span class="keyword">is</span> valid.: file /<span class="type">Users</span>/<span class="type">John</span>/<span class="type">AmazingApp</span>/<span class="type">Sources</span>/<span class="type">AppDelegate</span>.swift, line <span class="number">17</span></div></pre></td></tr></table></figure>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>处理不可空的可选类型有一下几个方法:</p>
<ol>
<li>用懒加载属性, 替代不可空的可选类型。</li>
<li>适当的依赖管理, 替代不可空的可选类型。</li>
<li>在遇到这种情况的时候, 让程序崩溃, 并抛出异常。</li>
</ol>
<h3 id="That’s-it"><a href="#That’s-it" class="headerlink" title="That’s it!"></a>That’s it!</h3><p><a href="https://medium.com/@johnsundell/handling-non-optional-optionals-in-swift-e5706390f56f">原文地址</a></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我是一名来自中国的 iOS 程序员, 对技术有着浓厚的兴趣, 在学习的过程中, 发现了很多来自国外的优秀博客。为了更好的学习这些文章, 产生了将这些文章翻译成中文的想法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;optional&lt;/strong&gt;, 可以说是 Swift 中最为重要的特性, 也是它跟 &lt;code&gt;Objective-C&lt;/code&gt; 不同的关键特征。在编码的时候强制处理那些可能为空的值, 可以让程序更具有可预测性, 减少错误发生的机会。&lt;/p&gt;
&lt;p&gt;然而在开发中我们经常会遇到一些变量, 明明是 &lt;code&gt;optional&lt;/code&gt; 的, 但在逻辑又一定是非空的。比如说 &lt;code&gt;controller&lt;/code&gt; 中的 &lt;code&gt;view&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
      <category term="翻译" scheme="http://www.CepheusSun.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Swifty Tips ⚡️</title>
    <link href="http://www.CepheusSun.com/Swifty%20Tips.html"/>
    <id>http://www.CepheusSun.com/Swifty Tips.html</id>
    <published>2017-05-29T16:05:23.000Z</published>
    <updated>2017-05-29T17:23:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 开发中的一些小的技巧</p>
<p>刚开始的时候, 特别好奇大厂是怎么搞的, 他们的项目长什么样子, 他们用哪些库…想在巨人的肩膀上开发, 免得浪费时间在那些已经有很好解决方案的事情上。</p>
<p>四年前，我和团队中很多很厉害的人讨论过一些编程实践。今天就分享一些东西吧。</p>
<p>欢迎指正！🚀</p>
<a id="more"></a>
<h2 id="滥用引用类型"><a href="#滥用引用类型" class="headerlink" title="滥用引用类型"></a>滥用引用类型</h2><p>只有“动态”对象才使用引用类型。这里的“动态”对象是什么呢？看下面的代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> model: <span class="type">String</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> cars: [<span class="type">Car</span>]</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchCars</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">registerCar</span><span class="params">(<span class="number">_</span> car: Car)</span></span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>🚗 在这里只是一个值。他代表的就是一些数据。就像 <code>1</code>、<code>2</code>、<code>3</code>。 这种数据是“静态”的数据(死的)。 它不会处理任何东西, 所以它也没有必要是“动态”的, 也就是说, 没必要把它定义成引用类型。</p>
<p><strong>另一方面:</strong></p>
<p><code>CarManager</code> 就需要是一个“动态”的对象。因为这个对象会发起网络请求, 然后将请求结果保存起来。在值类型对象中是不能执行异步任务的, 因为他们是“静态”的数据。我们需要的 <code>CarManager</code> 对象在一定的范围内是应该是动态的, 他会请求数据, 也会注册新的 <code>Car</code>。</p>
<p>这个主题完全可以写一篇文章来深入。推荐看看 <a href="https://news.realm.io/news/andy-matuschak-controlling-complexity/">Andy Matuschak 的文章</a>, 和 <a href="https://developer.apple.com/videos/play/wwdc2015/414/">WWDC</a></p>
<h2 id="隐式解包可选类型"><a href="#隐式解包可选类型" class="headerlink" title="隐式解包可选类型(!)"></a>隐式解包可选类型(<code>!</code>)</h2><p>默认不要隐式解包可选类型。 在大多数场景中你都可能会忘掉这件事情。但是在一些特殊情况下应该这样做来减少编译器的压力。而且我们也需要去理解这件事情背后的逻辑。</p>
<p>基本上, 如果这个属性在初始化的过程中必须为 <code>nil</code> 但是之后就会被赋值,  就可以定义这个属性为 optional。因为你肯定不会在赋值之前访问这个属性, 如果编译器一直警告这个值可能为 <code>nil</code> 真的挺讨厌的。</p>
<p>看看xib中拖出来的属性:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeView</span>: <span class="title">UIView</span> </span>&#123;</div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">let</span> nameLabel: <span class="type">UILabel</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这样定义的话, 编译器就会让你在初始化方法中给<code>nameLabel</code>赋值。因为这行代码告诉编译器这个 <code>View</code> 无论什么时候都有 <code>nameLabel</code>。 但是, 有病啊！肯定不能这么干啊。因为其实在 <code>initWithCoder</code> 中已经帮我们实现了 <code>xib</code> 中的 <code>label</code> 和这个属性之间的关联。明白了吗？ 这个值永远都不可能为空, 就没有必要判断这个东西是不是存在了。所以也不需要去赋值了啊。</p>
<blockquote>
<p>你:这玩意儿肯定不可能是空, 别瞎几把报错了<br>编译器: 好的!</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeView</span>: <span class="title">UIView</span> </span>&#123;</div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> nameLabel: <span class="type">UILabel</span>!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Q:</strong> 在dequeue一个tableviewCell 的时候能不能(<code>!</code>)?<br><strong>A:</strong> 还是不要吧！至少给一个 Crash 啊</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> cell = tableView.dequeueCell(...) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">fatalError</span>(<span class="string">"Cannot dequeue cell with identifier <span class="subst">\(cellID)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="滥用-AppDelegate"><a href="#滥用-AppDelegate" class="headerlink" title="滥用 AppDelegate"></a>滥用 AppDelegate</h2><p><code>AppDelegate</code> 不是拿来给你做保存全局变量的容器的(全局属性、工具方法、管理类等等。)他只是一个用来实现一些协议的类而已。放过它吧！</p>
<p>在 <code>applicationDidFinishLaunching</code> 方法里肯定都会做一些很重要的事情, 但是当项目不断变大的时候这种情况很容易变的很恐怖。创建新的类(文件)来做这些事情吧！</p>
<p><strong>👎 Don’t:</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> persistentStoreCoordinator: <span class="type">NSPersistentStoreCoordinator</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">rgb</span><span class="params">(r: CGFloat, g: CGFloat, b: CGFloat)</span></span> -&gt; <span class="type">UIColor</span> &#123; ... &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">appDidFinishLaunching</span>... </span>&#123;</div><div class="line">    <span class="type">Firebase</span>.setup(<span class="string">"3KDSF-234JDF-234D"</span>)</div><div class="line">    <span class="type">Firebase</span>.logLevel = .verbose</div><div class="line">    <span class="type">AnotherSDK</span>.start()</div><div class="line">    <span class="type">AnotherSDK</span>.enableSomething()</div><div class="line">    <span class="type">AnotherSDK</span>.disableSomething()</div><div class="line">    <span class="type">AnotherSDK</span>.anotherConfiguration()</div><div class="line">    persistentStoreCoordinator = ...</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>👍 Do:</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">appDidFinishLaunching</span>... </span>&#123;</div><div class="line">    <span class="type">DependencyManager</span>.configure()</div><div class="line">    <span class="type">CoreDataStack</span>.setup()</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>给一个方法的某些参数设置默认值是非常方便的事情。如果没有这个特性的话, 可能就需要给同一个功能写好几个方法了。像下面一样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(<span class="number">_</span> string: String, options: String?)</span></span> &#123; ... &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(<span class="number">_</span> string: String)</span></span> &#123;</div><div class="line">  <span class="built_in">print</span>(string, options: <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有默认参数值, 就可以是这样的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(<span class="number">_</span> string: String, options: String? = <span class="literal">nil</span>)</span></span> &#123;...&#125;</div></pre></td></tr></table></figure>
<p>很简单对吧！ 给自定义 UI 组件设置默认颜色、提供默认的参数、给网络请求添加默认的超时时间等等。但是, 使用这个语法糖在遇到依赖注入的时候就要小心了。</p>
<p>看下面的例子:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketsViewModel</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> service: <span class="type">TicketService</span></div><div class="line">    <span class="keyword">let</span> database: <span class="type">TicketDatabase</span></div><div class="line">    <span class="keyword">init</span>(service: <span class="type">TicketService</span>,</div><div class="line">       database: <span class="type">TicketDatabase</span>) &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 App target:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> model = <span class="type">TicketsViewModel</span>(</div><div class="line">  service: <span class="type">LiveTicketService</span>()</div><div class="line">  database: <span class="type">LiveTicketDatabase</span>()</div><div class="line">)</div></pre></td></tr></table></figure>
<p>在 Test target:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> model = <span class="type">TicketsViewModel</span>(</div><div class="line">    service: <span class="type">MockTicketService</span>()</div><div class="line">    database: <span class="type">MockTicketDatabase</span>()</div><div class="line">)</div></pre></td></tr></table></figure>
<p>在这里使用协议的原因就是把这些功能从具体的类中抽象出来。这就使得你可以向这个 <code>viewModel</code> 中注入任何你想要的具体实现。 如果这里你把 <code>LiveTicketService</code> 作为默认的参数, 这就使得<code>TicketsViewModel</code> 依赖了 <code>LiveTicketService</code>这么一个具体的类型。这跟最初想要达到的目的有了一些冲突。</p>
<p><strong>现在没那么方便了吧？</strong></p>
<p>想象一下在你 App 还有 Test 两个 target 中。 <code>TicketsViewModel</code> 会被同时添加到两个 target 中, 然后把 <code>LiveTicketService</code> 和 <code>MockTicketService</code> 分别添加。如果 <code>TicketsViewModel</code>添加了对 <code>LiveTicketService</code> 的依赖。 Test target 肯定就编译不过了。</p>
<h2 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h2><p>这… 就是很爽啊！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(<span class="number">_</span> numbers: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> numbers.<span class="built_in">reduce</span>(<span class="number">0</span>, +)</div><div class="line">&#125;</div><div class="line">sum(<span class="number">1</span>,<span class="number">2</span>)      <span class="comment">// 3</span></div><div class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)    <span class="comment">// 6</span></div><div class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<h2 id="使用类型嵌套"><a href="#使用类型嵌套" class="headerlink" title="使用类型嵌套"></a>使用类型嵌套</h2><p>Swift 支持内部类。所以有用就可以这么做：</p>
<p><strong>👎 Don’t:</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PhotoCollectionViewCellStyle</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="keyword">default</span></div><div class="line">    <span class="keyword">case</span> photoOnly</div><div class="line">    <span class="keyword">case</span> photoAndDescription</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个枚举可能在 <code>PhotoCollectionViewCell</code> 之外就不会再使用到了。没理由把这个枚举声明成全局的。</p>
<p><strong>👍 Do:</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoCollectionViewCell</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> <span class="keyword">default</span></div><div class="line">        <span class="keyword">case</span> photoOnly</div><div class="line">        <span class="keyword">case</span> photoAndDescription</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> style: <span class="type">Style</span> = .<span class="keyword">default</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这很容易理解, 毕竟 <code>Style</code> 本来就是用来标记 <code>PhotoCollectionViewCell</code> 的。而且还少了23个字符呢。</p>
<h2 id="使用-final-关键字-🏁"><a href="#使用-final-关键字-🏁" class="headerlink" title="使用 final 关键字 🏁"></a>使用 final 关键字 🏁</h2><p>如果你不需要拓展某些类, 也不希望这些类被拓展, 使用 <code>final</code> 修饰它。不用担心犯错, 比如 <code>PhotoCollectionViewCell</code> 这个类, 你还有可能继承它吗？</p>
<p>而且:<strong>这么做可以节约编译时间。</strong></p>
<h2 id="给常量命名空间"><a href="#给常量命名空间" class="headerlink" title="给常量命名空间"></a>给常量命名空间</h2><p>在 OC 中是通过在全局的常量前面加 <code>PFX</code> 或者 <code>k</code> 来给这些常量命名空间的。但是 Swift 可不这样。</p>
<p><strong>👎 Don’t:</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> ket kAnimationDuration: <span class="type">TimeInterval</span> = <span class="number">0.3</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">let</span> kLowAlpha = <span class="number">0.2</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">let</span> kAPIKey = <span class="string">"13511-5234-5234-59234"</span></div></pre></td></tr></table></figure>
<p><strong>👍 Do:</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Constant</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">UI</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">let</span> animationDuration: <span class="type">TimeInterval</span> = <span class="number">0.3</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">let</span> lowAlpha: <span class="type">CGFloat</span> = <span class="number">0.2</span>  </div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Analytics</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">let</span> apiKey = <span class="string">"13511-5234-5234-59234"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我个人的偏好是使用 <code>C</code> 来代替 <code>Constant</code>, 他已经够清晰了。这个可以看你自己喜欢了。</p>
<p><strong>Before:</strong> <code>kAnimationDuration</code> 或者 <code>kAnalyticsAPIKey</code><br><strong>After:</strong> <code>C.UI.animationDuration</code> 或者 <code>C.Analytics.apiKey</code></p>
<h2 id="的使用"><a href="#的使用" class="headerlink" title="_ 的使用"></a><code>_</code> 的使用</h2><p><code>_</code> 是对没有使用到的变量的占位符。他就是告诉编译器”这个值是什么不重要”。 不然编译器会有警告⚠️。</p>
<p><strong>👎 Don’t</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = name &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Name is not nil."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>optional</code>就像一个盒子。可以直接看他是不是空的, 没必要每次都把里面的东西拿出来。</p>
<p><strong>👍 Do:</strong></p>
<ul>
<li>判空</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> name != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Name is not nil."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>返回值没用</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">_</span> = manager.removeCar(car) <span class="comment">// 成功返回true</span></div></pre></td></tr></table></figure>
<ul>
<li>ConpletionHandler</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">service.fetchItems &#123;data, error , <span class="number">_</span> <span class="keyword">in</span></div><div class="line">    <span class="comment">// 第三个参数我不在乎他是什么</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h2><p>这点适用于所有需要人类去阅读的语言。代码总是不那么容易理解的, 不要浪费别人的精力。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">driver.driving()</div></pre></td></tr></table></figure>
<p>这是在干什么？</p>
<ul>
<li>是把 <code>driver</code> 标记成 <code>driving</code> 状态？</li>
<li>还是检查 <code>driver</code> 是不是 <code>driving</code> 状态, 并且返回一个 <code>bool</code> 值？</li>
</ul>
<p><strong>如果要点进去看才知道这方法是干什么的, 这个命名就是失败了。</strong>多人协同开发或者处理遗留项目的时候, 你读别人代码的时间比你写代码的时间都要长。所以在命名的时候想着别让看你代码的人痛苦。</p>
<h2 id="关于-print"><a href="#关于-print" class="headerlink" title="关于 print"></a>关于 print</h2><p>很严肃的说, 不要得到一个 <code>error</code> 或者 <code>response</code> 就在控制台打印出来。你这么做还不如不打印呢！搞得控制台一堆乱七八糟的东西看起来真的很爽吗？</p>
<p><strong>Do:</strong></p>
<ul>
<li>在 <code>framework</code> 中使用 <code>error</code> 级的 <code>log level</code>。</li>
<li>使用一些能够让你有不同输出级别的 log 库。<em>XGGLogger</em>、<em>SwiftyBeaver</em></li>
<li>不要用 log 来 debug 了。Xcode 有很多有用的工具<a href="https://www.objc.io/issues/19-debugging/debugging-case-study/">Debugging: A Case Study</a></li>
</ul>
<h2 id="没用的代码"><a href="#没用的代码" class="headerlink" title="没用的代码"></a>没用的代码</h2><p>经常在一些老项目里面见到被注释掉的代码, 但是出来没有通过把这些代码打开来解决过问题。所以, 既然这些代码都没有什么用了, 就删了它! 还能增加代码的可读性, 看起来整洁的代码总要让人舒服一些。</p>
<p><strong>最后推荐一个好文<a href="https://medium.com/@gokselkoksal/swifty-tips-%EF%B8%8F-8564553ba3ec">Using SwiftLint and Danger for Swift Best Practices</a></strong></p>
<p><strong><a href="https://medium.com/@gokselkoksal/swifty-tips-%EF%B8%8F-8564553ba3ec">原文地址</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 开发中的一些小的技巧&lt;/p&gt;
&lt;p&gt;刚开始的时候, 特别好奇大厂是怎么搞的, 他们的项目长什么样子, 他们用哪些库…想在巨人的肩膀上开发, 免得浪费时间在那些已经有很好解决方案的事情上。&lt;/p&gt;
&lt;p&gt;四年前，我和团队中很多很厉害的人讨论过一些编程实践。今天就分享一些东西吧。&lt;/p&gt;
&lt;p&gt;欢迎指正！🚀&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
      <category term="翻译" scheme="http://www.CepheusSun.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift Syntax Cheat Codes</title>
    <link href="http://www.CepheusSun.com/Swift%20Syntax%20Cheat%20Codes.html"/>
    <id>http://www.CepheusSun.com/Swift Syntax Cheat Codes.html</id>
    <published>2017-05-23T16:05:23.000Z</published>
    <updated>2017-05-24T03:24:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍一些很常见的语法。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() -&gt; <span class="type">Void</span></div></pre></td></tr></table></figure>
<p>也叫做 <code>匿名函数</code>。闭包是自包含的函数代码块，可以在代码中被传递和使用。在 <code>C</code> 和 <code>OC</code> 中有 <code>block</code> 与之对应。</p>
<p>如果你之前就有 iOS 开发经验, 你肯定看到过 UIView 动画的 API</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animate</span>(<span class="title">withDuration</span> <span class="title">duration</span>: <span class="title">NSTimeInterval</span>,</div><div class="line"> <span class="title">animations</span>: @<span class="title">escaping</span>() -&gt; <span class="title">Void</span>)</span></div></pre></td></tr></table></figure>
<p><code>animations</code>就是动画的参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">10.0</span>, animations: &#123;</div><div class="line">    button.alpha = <span class="number">0</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>animationWithDuration</code> 方法就会使用这个闭包做一件事情:让button慢慢的消失。</p>
<h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">10.0</span>) &#123; </div><div class="line">    button.alpha = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是 Swift 的特性之一, 这样可以节省一些没什么必要存在的代码。看这段的代码, 跟上面的代码调用的是同一个 API, 只是这段代码使用了更简洁的语法。</p>
<p>因为 <code>animate</code> 这个方法的最后一个参数是一个闭包—<strong>尾随闭包</strong>。尾随闭包允许我们在编码的时候省略掉最后的参数名, 并让他从参数列表那个括号里面移出来。这样会让代码更优雅简洁。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(<span class="number">_</span> message: String, completion: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(message)</div><div class="line">    completion()</div><div class="line">&#125;</div><div class="line"><span class="comment">// 没有使用尾随闭包</span></div><div class="line">say(<span class="string">"Hello"</span>, completion: &#123;</div><div class="line">    <span class="comment">// prints: "Hello" </span></div><div class="line">    <span class="comment">// Do some other stuff</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 使用了尾随闭包</span></div><div class="line">say(<span class="string">"Hello"</span>) &#123;</div><div class="line">    <span class="comment">// prints: "Hello"</span></div><div class="line">    <span class="comment">// Do some other stuff</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span></div></pre></td></tr></table></figure>
<p>类型别名是一个很有用的小工具, 能尽可能少的减少重复代码。看下面的例子:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dance</span><span class="params">(<span class="keyword">do</span>:<span class="params">(Int, String, Double)</span></span></span> -&gt; (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Double</span>)) &#123;&#125;</div></pre></td></tr></table></figure>
<p>这段代码的功能其实很简单, 但是如果在其他方法中也需要传递这个闭包的话, 我们就应该记住这个闭包, 并且保证在任何我们使用它的地方都是一致的, 不然编译器可能就不高兴了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dance</span><span class="params">(<span class="keyword">do</span>: <span class="params">(Int, String, Double)</span></span></span> -&gt; (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Double</span>)) &#123; &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sing</span><span class="params">(<span class="keyword">do</span>: <span class="params">(Int, String, Double)</span></span></span> -&gt; (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Double</span>)) &#123; &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">act</span><span class="params">(<span class="keyword">do</span>: <span class="params">(Int, String, Double)</span></span></span> -&gt; (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Double</span>)) &#123; &#125;</div></pre></td></tr></table></figure>
<p>但是如果某个时刻我们需要修改一下这个闭包。这就尴尬了, 上面三个方法都需要去修改。 这就是使用<strong>类型别名</strong>的场景。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">TripleThreat</span> = (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Double</span>) -&gt; (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Double</span>)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dance</span><span class="params">(dance: TripleThreat)</span></span> &#123; &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">act</span><span class="params">(act: TripleThreat)</span></span> &#123; &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sing</span><span class="params">(sing: TripleThreat)</span></span> &#123; &#125;</div></pre></td></tr></table></figure>
<p>这样写的话, 只要我们需要修改这个闭包的时候, 就只需要修改一个地方了。</p>
<p><strong>喜闻乐见的类型别名</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typealias Void = ()</div><div class="line">typealias NSTimeInterval = Double</div></pre></td></tr></table></figure>
<h3 id="参数名缩写"><a href="#参数名缩写" class="headerlink" title="参数名缩写"></a>参数名缩写</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$<span class="number">0</span>,$<span class="number">1</span>,$<span class="number">2</span></div></pre></td></tr></table></figure>
<p>一个闭包内有参数的情况下, 你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会 通过函数类型进行推断。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(<span class="number">_</span> message: String, completion: <span class="params">(<span class="number">_</span> goodbye: String)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(message)</div><div class="line">    completion(<span class="string">"Goodbye"</span>)</div><div class="line">&#125;</div><div class="line">...</div><div class="line">say(<span class="string">"Hi"</span>) &#123; (goodbye: <span class="type">String</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(goodbye)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints: "Hi"</span></div><div class="line"><span class="comment">// prints: "Goodbye"</span></div></pre></td></tr></table></figure>
<p>这个例子中，这个尾随闭包有一个 <code>String</code> 类型的 <code>goodbye</code> 参数。Xcode 会自动把它放在一个元组里面。用 <code>in</code> 来表示参数、返回值的结束。并另起一行来实现我们想要的功能。当这个闭包很小的时候，这样写就显得代码非常的冗长了。我们来改造一下段代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(goodbye: <span class="type">String</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></div></pre></td></tr></table></figure>
<p>这段代码完全没有必要写出来。使用参数名缩写就好了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say(<span class="string">"Hi"</span>) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</div><div class="line"><span class="comment">// prints: "Hi"</span></div><div class="line"><span class="comment">// prints: "Goodbye"</span></div></pre></td></tr></table></figure>
<p>你看, 这样写完全省略掉了闭包的参数还有返回值声明的代码。因为在这个场景中，我们完全没有必要使用参数名。每个参数都按照声明的顺序命名好了。这么简单, 直接放在一行代码里就可以了。</p>
<p>如果有不止一个参数的时候应该怎么弄呢？我也不想解释了, 直接看下面的代码: </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(goodbye: <span class="type">String</span>, name: <span class="type">String</span>, age: <span class="type">Int</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line"><span class="comment">// $0: goodbye</span></div><div class="line"><span class="comment">// $1: name</span></div><div class="line"><span class="comment">// $2: age</span></div></pre></td></tr></table></figure>
<h3 id="返回-Self"><a href="#返回-Self" class="headerlink" title="返回 Self"></a>返回 Self</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-&gt; <span class="type">Self</span></div></pre></td></tr></table></figure>
<p>Swift2.0 带来的一大堆操作符(map, flatmap), 这些操作符更给力的是让我们能够使用 <code>.</code> 语法链式的调用一系列方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span> , <span class="number">2</span>, <span class="number">3</span>, <span class="literal">nil</span>, <span class="number">5</span>]</div><div class="line">    .flatMap &#123;$<span class="number">0</span>&#125;    <span class="comment">// 移除空</span></div><div class="line">    .<span class="built_in">filter</span> &#123;$<span class="number">0</span> &lt; <span class="number">3</span>&#125; <span class="comment">// 过滤大于2的值</span></div><div class="line">    .<span class="built_in">map</span> &#123;$<span class="number">0</span> * <span class="number">100</span>&#125;  <span class="comment">// 每个值放大100倍</span></div><div class="line"><span class="comment">// [100, 200]</span></div></pre></td></tr></table></figure>
<p>这样太优雅了, 既可读又易于理解。</p>
<p>假设我们为<code>String</code>建一个扩展, 在字符串的本身上执行一些操作, 而不使函数返回 <code>Void</code> 而是他自己.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// extension UIView</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(backgroundColor: UIColor)</span></span> -&gt; <span class="type">Self</span> &#123;</div><div class="line">    backgroundColor = color</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(cornerRadius: CGFloat)</span></span> -&gt; <span class="type">Self</span> &#123;</div><div class="line">    layer.cornerRadius = <span class="number">3</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> view = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">10</span>, height: <span class="number">10</span>))</div><div class="line">          .with(backgroundColor: .black)</div><div class="line">          .with(cornerRadius: <span class="number">3</span>)</div></pre></td></tr></table></figure>
<h3 id="That’s-it"><a href="#That’s-it" class="headerlink" title="That’s it!"></a>That’s it!</h3><p><a href="https://medium.com/swift-programming/swift-syntax-cheat-codes-9ce4ab4bc82e">原文地址</a></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我是一名来自中国的 iOS 程序员, 对技术有着浓厚的兴趣, 在学习的过程中, 发现了很多来自国外的优秀博客。为了更好的学习这些文章, 产生了将这些文章翻译成中文的想法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍一些很常见的语法。&lt;/p&gt;
&lt;h3 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h3&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;() -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也叫做 &lt;code&gt;匿名函数&lt;/code&gt;。闭包是自包含的函数代码块，可以在代码中被传递和使用。在 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;OC&lt;/code&gt; 中有 &lt;code&gt;block&lt;/code&gt; 与之对应。&lt;/p&gt;
&lt;p&gt;如果你之前就有 iOS 开发经验, 你肯定看到过 UIView 动画的 API&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
      <category term="翻译" scheme="http://www.CepheusSun.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Picking the right way of failing in Swift</title>
    <link href="http://www.CepheusSun.com/Picking%20the%20right%20way%20of%20failing%20in%20Swift.html"/>
    <id>http://www.CepheusSun.com/Picking the right way of failing in Swift.html</id>
    <published>2017-05-20T04:37:45.000Z</published>
    <updated>2017-05-20T04:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 的一大特色就是编译安全。这使得我们开发者能够更容易的编写出可预测性的代码, 并且能勾减少运行时错误的发生。但是, 在实际的情况中, 错误发生的原因是千奇百怪的。</p>
<p>我们今天来看一下如果正确的去处理各类错误, 以及我们有什么工具来做这件事情。上一篇文章研究了如何处理 <code>non-optional</code>。 在那篇文章中我使用 <code>guard</code> + <code>preconditionFailure()</code> 代替了强制解包。</p>
<p>之后很多人都在问 <code>preconditionFailure()</code> 和 <code>assert()</code> 有什么区别。 在这篇文章中。我们再仔细的看看这些语言特性。最重要的是在什么情况下使用哪一种？</p>
<a id="more"></a>
<h3 id="Let’s-start-with-a-list"><a href="#Let’s-start-with-a-list" class="headerlink" title="Let’s start with a list"></a>Let’s start with a list</h3><p>我先把我知道的所有异常处理方法列举出来。</p>
<ul>
<li><strong>返回 <code>nil</code> 或者是一个 error 枚举值</strong>, 最简单的异常处理机制就是直接在发生错误的方法中返回 <code>nil</code> 或者是 <code>.error</code>(使用了一个枚举来做为返回值类型的时候)。这中做法在很多的场景中都是有效的, 但是如果任何情况下都这么干的话。可能会导致你代码中的 API 编的非常繁琐。也会带来一些逻辑的错误。</li>
<li><strong>抛出错误信息</strong>, 这要求在处理潜在的错误是使用<code>do</code>、<code>try</code>、<code>catch</code> 语句。另外如果使用 <code>try？</code>错误会被忽略掉。</li>
<li><strong>使用断言 <code>assert()</code> 和 <code>assertionFailure()</code></strong>, 来确定这个表达式是不是成立。默认情况下, 在 Debug 环境下会导致异常的抛出。在 release 下一场会被忽略。所以无法保证这个断言在出发的时候, 程序会立马停止。所以这种模式也可以被理解运行时警告。</li>
<li><strong>使用 <code>precondition()</code> 和 <code>preconditionFailure()</code></strong>来代替断言。跟断义最大的区别就是它们在任何情况下都会发生, 可以确保在发生异常的时候程序会立马停止。</li>
<li><strong>调用 <code>fataError()</code></strong>, 这个函数在 Xcode 自动生成的 <code>init(coder:)</code> 中大概都看到过。只要这个方法被调用就会立马杀掉当前进程。</li>
<li><strong>调用 <code>exit()</code></strong>, 使用这个代码直接结束进程。这在命令行还有脚本中是非常有效的方法。</li>
</ul>
<h3 id="是否可恢复"><a href="#是否可恢复" class="headerlink" title="是否可恢复"></a>是否可恢复</h3><p>这个异常发生之后程序还能否从异常中恢复是选择异常处理方式的重要因素。</p>
<p>比如说。我们向服务器发强请求, 然后得到了错误的请求结果。这种情况无论我们是多么牛逼的程序员, 我们使用了多么强大的服务器基本上肯定都会发生。把这种异常看作是致命异常或者是不可恢复的异常可能就不对了。这种场景中, 我们希望的可能就是给用户展示一些错误信息就可以了。</p>
<p>既然这样, 在这种场景中, 选择什么样的方法来处理异常呢？如果你仔细看了上面的列表, 我们其实可以把这些按照是否可恢复归位两类:</p>
<p><strong>可恢复的</strong></p>
<ul>
<li>返回 <code>nil</code> 或者一个 <code>error</code> 枚举值。</li>
<li>抛出错误信息。</li>
</ul>
<p><strong>不可恢复的</strong></p>
<ul>
<li>assert()</li>
<li>precondition()</li>
<li>fatalError()</li>
<li>exit()</li>
</ul>
<p>既然我们处理的是一个异步的任务, 返回 <code>nil</code> 或者 <code>error</code> 枚举值就是最好的选择了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataLoader</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Result</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> success(<span class="type">Data</span>)</div><div class="line">        <span class="keyword">case</span> failure(<span class="type">Error</span>?)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadData</span><span class="params">(from url: URL, completionHandler: @escaping <span class="params">(Result)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: url) &#123;</div><div class="line">            data, response, error <span class="keyword">in</span></div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</div><div class="line">                completionHandler(.failure(error))</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            completionHandler(.success(data))</div><div class="line">        &#125;</div><div class="line">        task.resume()</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果任务是同步的, 抛出错误应该是最好的方法了。毕竟 API 也是这样设计的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringFormatter</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> emptyString</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(<span class="number">_</span> string:String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">guard</span> !string.isEmpty <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.emptyString</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> string.replacingOccurrences(of: <span class="string">"\n"</span>, with: <span class="string">" "</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在有些情况下, 错误是不可恢复的。比如说, 我们需要在程序启动的时候加载配置文件。如果这个配置文件丢失了, 这会把程序带入未定义的状态中。所以这种情况下 crash 可能就要比让程序就运行好得多了。这种情况下, 使用更强的并且不可恢复的方法来让程序崩溃会是更合适的。</p>
<p>在这个例子中, 使用 <code>preconditionFailure()</code> 来停止运行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> config = <span class="type">FileLoader</span>().loadFile(name: <span class="string">"Config.json"</span>) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">preconditionFailure</span>(<span class="string">"Failed to load config file"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="程序错误和运行错误"><a href="#程序错误和运行错误" class="headerlink" title="程序错误和运行错误"></a>程序错误和运行错误</h3><p>另外一个重要的标准是:异常的发生原因是逻辑还是配置, 或者说这个错误是不是程序流程中合法的部分。基本上判断的标准就是这个错误的原因是因为程序员还是外部因素。</p>
<p>为了减少麻烦, 可能你更愿意使用不可恢复的方法来处理各类错误。这样你就不用写各种代码来处理各种特殊情况了, 并且如果测试做得好的话, 这些错误就能够早的被捕获到了。</p>
<p>比如。 我们在做一个界面, 需要一个 <code>viewModel</code> 在使用之前跟他做好绑定。这个 <code>viewModel</code> 在我们的代码中是一个 <code>optional</code> 类型, 但是我们又不希望每次使用的时候都要强制解包。我们也不希望在这个 <code>viewmodel</code> 莫名其妙消失的时候程序在生产环境中崩溃。使用断言在 <code>debug</code> 下获得错误信息就足够了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailView</span>: <span class="title">UIView</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ViewModel</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> title: <span class="type">String</span></div><div class="line">        <span class="keyword">var</span> subtitle: <span class="type">String</span></div><div class="line">        <span class="keyword">var</span> action: <span class="type">String</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> viewModel: <span class="type">ViewModel</span>?</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>()</div><div class="line">    <span class="keyword">let</span> subtitleLabel = <span class="type">UILabel</span>()</div><div class="line">    <span class="keyword">let</span> actionButton = <span class="type">UIButton</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didMoveToSuperview</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didMoveToSuperview()</div><div class="line">        </div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> viewModel = viewModel <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">assertionFailure</span>(<span class="string">"No view model assigned to DetailView."</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        titleLabel.text = viewModel.title</div><div class="line">        subtitleLabel.text = viewModel.subtitle</div><div class="line">        actionButton.setTitle(viewModel.action, <span class="keyword">for</span>: .normal)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是: 我们必须在上面的 <code>guard</code> 表达式中 <code>return</code>, 不然在 <code>release</code> 条件下 <code>assertFailure()</code> 也没什么作用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我希望这篇文章有助于让你理解到各种异常处理方法的区别。我的建议是不要只是专注于技术, 而是要在不同的场景中尝试使用不同的方法。一般情况下, 我更建议大家尽量在程序出错的时候恢复过来, 除非异常是致命的, 都不要影响用户体验。</p>
<p>另外 <code>print(error)</code> 并不是一个异常处理机制。</p>
<p>Thanks for reading! 🚀</p>
<h3 id="That’s-it"><a href="#That’s-it" class="headerlink" title="That’s it!"></a>That’s it!</h3><p><a href="https://medium.com/@johnsundell/picking-the-right-way-of-failing-in-swift-e89125a6b5b5">原文地址</a></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我是一名来自中国的 iOS 程序员, 对技术有着浓厚的兴趣, 在学习的过程中, 发现了很多来自国外的优秀博客。为了更好的学习这些文章, 产生了将这些文章翻译成中文的想法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 的一大特色就是编译安全。这使得我们开发者能够更容易的编写出可预测性的代码, 并且能勾减少运行时错误的发生。但是, 在实际的情况中, 错误发生的原因是千奇百怪的。&lt;/p&gt;
&lt;p&gt;我们今天来看一下如果正确的去处理各类错误, 以及我们有什么工具来做这件事情。上一篇文章研究了如何处理 &lt;code&gt;non-optional&lt;/code&gt;。 在那篇文章中我使用 &lt;code&gt;guard&lt;/code&gt; + &lt;code&gt;preconditionFailure()&lt;/code&gt; 代替了强制解包。&lt;/p&gt;
&lt;p&gt;之后很多人都在问 &lt;code&gt;preconditionFailure()&lt;/code&gt; 和 &lt;code&gt;assert()&lt;/code&gt; 有什么区别。 在这篇文章中。我们再仔细的看看这些语言特性。最重要的是在什么情况下使用哪一种？&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
      <category term="翻译" scheme="http://www.CepheusSun.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Using lazy properties in Swift</title>
    <link href="http://www.CepheusSun.com/Using%20lazy%20properties%20in%20Swift.html"/>
    <id>http://www.CepheusSun.com/Using lazy properties in Swift.html</id>
    <published>2017-05-20T04:36:45.000Z</published>
    <updated>2017-05-20T04:37:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>懒加载属于让你可以在需要的时候才初始化, 而不是在初始化这个对象的时候就必须要。懒加载可以用来避免 optional 的使用, 当某个属性的初始化耗费很多资源的时候会提升性能。当然使用懒加载也能让对象的初始化方法看起来很清爽, 因为某些设置会在这个对象的生命周期中被推迟。</p>
<p>这周我们来学习一下 Swift 中懒加载的定义, 以及使用。</p>
<a id="more"></a>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>定义一个懒加载属性最简单的办法就是在 <code>var</code> 前加一个 <code>lazy</code> 关键字, 并且还要给 出默认的值。这个默认值会在这个属性被第一次访问的时候被指定, 也就是说在这个对象的初始化方法中这个就不需要再去初始化这个属性了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> cahce = <span class="type">Cache</span>&lt;<span class="type">File</span>&gt;()</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadFile</span><span class="params">(name name: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">File</span> &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedFile = cahce[name] &#123;</div><div class="line">            <span class="keyword">return</span> cachedFile</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">let</span> file = <span class="keyword">try</span> loadFileFromDisk(fileName: name)</div><div class="line">        cahce[name] = file</div><div class="line">        <span class="keyword">return</span> file</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用工厂方法"><a href="#使用工厂方法" class="headerlink" title="使用工厂方法"></a>使用工厂方法</h3><p>有些时候我们可能需要在这个属性在懒加载的时候设置一些东西, 只是简单的使用它的初始化方法可能就没有那么方便了。这种情况下, 更方便的方法是把这个属性的初始化代理给一个工厂方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scene</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> eventManager: <span class="type">EventManager</span> = <span class="keyword">self</span>.makeEventManager()</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">makeEventManager</span><span class="params">()</span></span> -&gt; <span class="type">EventManager</span>&#123;</div><div class="line">        <span class="keyword">let</span> manager = <span class="type">EventManager</span>()</div><div class="line">        <span class="keyword">return</span> manager</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你不希望你的类里面全是各种 <code>make..()</code> 这类工厂方法, 你可以把这些方法放在一个专门的 <code>extension</code> 中</p>
<h3 id="使用自执行闭包"><a href="#使用自执行闭包" class="headerlink" title="使用自执行闭包"></a>使用自执行闭包</h3><p>除了使用工厂方法来返回这个属性值以外, 你也可以选择在这个属性声明的地方通过一个自执行的闭包来出初始化这个属性。我们看看上面这个情况, 我们应该怎么做吧！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> eventManager: <span class="type">EventManager</span> = &#123;</div><div class="line">   <span class="keyword">let</span> manager = <span class="type">EventManager</span>()</div><div class="line">    <span class="keyword">return</span> manager</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>这要做有一个好处: 让这个属性的在同一个地方声明和设置。当然阅读这些代码可能会比较不爽。特别是在这个属性的设置需要很长的代码的时候。我自己的规则是当这个属性的初始化方法只有两三行代码的时候。就是使用这样的方法来初始化懒加载属性。</p>
<h3 id="使用静态工厂方法"><a href="#使用静态工厂方法" class="headerlink" title="使用静态工厂方法"></a>使用静态工厂方法</h3><p>对于那些设置起来更复杂属性, 把这些代码放到其他的类中, 会是更好的办法。这么做, 可以让这个类更加专注于它自己的职责, 让这个类不至于那么复杂。当然这也可以在不使用子类的条件下, 在多个类中共享代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> actionButton: <span class="type">UIButton</span> = <span class="type">ViewFactory</span>.makeActionButton()</div></pre></td></tr></table></figure>
<p>在这个例子中, <code>ViewFactory</code> 这个类包含了这个 <code>controller</code> 中所有控件的初始化方法。不用引入更多的类, 也不用让继承树变复杂。如果我们希望在另外一个 <code>controller</code> 中使用这个按钮, 也只需要调用同一个 API 就好了 <code>ViewFactory.makeActionButton()</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可能有人会问, 有没有什么大一统的方法来使用懒加载呢？ 个人认为没有. 写代码就是这样, 选择最合适的方法来处理不同的业务需求才是最正确的做法。而且我自己也在日常开发中使用上面所有的方法。</p>
<p>Twitter 又一个问题: 使用不同的方法, 对编译时间有什么影响呢？我做了一些基本的测试, 并没有发现这其中有什么差别。当然这也跟这个懒加载属性有关。</p>
<p>Thanks for reading! 🚀</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;懒加载属于让你可以在需要的时候才初始化, 而不是在初始化这个对象的时候就必须要。懒加载可以用来避免 optional 的使用, 当某个属性的初始化耗费很多资源的时候会提升性能。当然使用懒加载也能让对象的初始化方法看起来很清爽, 因为某些设置会在这个对象的生命周期中被推迟。&lt;/p&gt;
&lt;p&gt;这周我们来学习一下 Swift 中懒加载的定义, 以及使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.CepheusSun.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.CepheusSun.com/tags/Swift/"/>
    
      <category term="翻译" scheme="http://www.CepheusSun.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
